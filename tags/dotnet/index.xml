<?xml version="1.0" encoding="utf-8" standalone="yes"?><rss version="2.0" xmlns:atom="http://www.w3.org/2005/Atom"><channel><title>Dotnet on -小佑-（&lt;ゝω·）キラbosh☆</title><link>https://yuchia-wei.github.io/tags/dotnet/</link><description>Recent content in Dotnet on -小佑-（&lt;ゝω·）キラbosh☆</description><generator>Hugo</generator><language>zh-TW</language><lastBuildDate>Wed, 16 Jul 2025 11:30:00 +0800</lastBuildDate><atom:link href="https://yuchia-wei.github.io/tags/dotnet/index.xml" rel="self" type="application/rss+xml"/><item><title>在 dockerfile 內使用 alpine 的 dotnet sdk image 建置 dotnet 服務</title><link>https://yuchia-wei.github.io/2025/07/use-dotnet-sdk-alpine-in-docker-file/</link><pubDate>Wed, 16 Jul 2025 11:30:00 +0800</pubDate><guid>https://yuchia-wei.github.io/2025/07/use-dotnet-sdk-alpine-in-docker-file/</guid><description>&lt;p>在我以前的工作環境中，由於建置機採用地端管理，且有儲存容量等限制，如何利用 docker 的 build cache 來增加儲存空間的利用率成了必須思考的議題。&lt;/p>
&lt;p>也因為我在規劃 &lt;strong>包含 opentelemetry auto instrumentation&lt;/strong> 的 base image 時，也會需要同時發布多種不同 linux 版本的 image，因此，這邊特別研究了多種不同 linux 發行版的 dotnet build 參數並應用在 dockerfile 之中，來讓一份 dockerfile 可以發布多種不同的成品，並且使用相同的建置階段。&lt;/p>
&lt;p>這邊使用的 github repo 為 &lt;a href="https://github.com/YuChia-Wei/otel-dotnet-auto-instrumentation" target="_blank" rel="noopener noreferrer">YuChia-Wei/otel-dotnet-auto-instrumentation&lt;/a>&lt;/p></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 3 : 其他包裝方法</title><link>https://yuchia-wei.github.io/2025/07/aspnetcore-webapi-custom-response-model-part3-wrapping-api-response-the-other-way/</link><pubDate>Wed, 16 Jul 2025 11:22:00 +0800</pubDate><guid>https://yuchia-wei.github.io/2025/07/aspnetcore-webapi-custom-response-model-part3-wrapping-api-response-the-other-way/</guid><description>&lt;p>先前在撰寫 wrapping response action filter 的時候其實有利用 ChatGPT 進行輔助，在與 ChatGPT 對話的過程中也有討論到使用 Middleware 處理回應包裝的部分，我想利用這一篇記錄一下當時的對話內容以及結論。
&lt;/br>
&lt;/br>
因此，本文大部分內容都是由 AI 產出，我再進行整理與調整。
&lt;/br>
&lt;/br>
&lt;div class="details admonition warning open">
 &lt;div class="details-summary admonition-title">
 &lt;span class="icon">&lt;svg class="icon"
 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512">&lt;!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) -->&lt;path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/>&lt;/svg>&lt;/span>警告&lt;span class="details-icon">&lt;svg class="icon"
 xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512">&lt;!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) -->&lt;path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"/>&lt;/svg>&lt;/span>
 &lt;/div>
 &lt;div class="details-content">
 &lt;div class="admonition-content">本文中所使用的方式我並沒有在正式環境中使用，僅是因為在先前與 ChatGPT 討論的過程中有針對這種做法進行討論，然後覺得這段適合保留下來而有這一篇文章。&lt;/div>&lt;/div>&lt;/div>&lt;/p></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 2 : 包裝例外</title><link>https://yuchia-wei.github.io/2024/11/aspnetcore-webapi-custom-response-model-part2-wrapping-exception/</link><pubDate>Sun, 17 Nov 2024 11:30:00 +0800</pubDate><guid>https://yuchia-wei.github.io/2024/11/aspnetcore-webapi-custom-response-model-part2-wrapping-exception/</guid><description>&lt;p>這篇為 「幫 AspNetCore WebApi 包上自己的 response model」 的第二部分 「包裝例外」。
&lt;/br>&lt;/p>
&lt;p>我將介紹如何在 ASP.NET Core Web API 中統一處理例外狀況，並將其包裝成標準化的回應格式。&lt;/p>
&lt;p>我會介紹以下兩種例外資料的包裝方法：&lt;/p>
&lt;ol>
&lt;li>使用 UseExceptionHandler Middleware&lt;/li>
&lt;li>使用 IExceptionFilter 介面&lt;/li>
&lt;/ol></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應</title><link>https://yuchia-wei.github.io/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/</link><pubDate>Sat, 12 Oct 2024 00:00:00 +0800</pubDate><guid>https://yuchia-wei.github.io/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/</guid><description>&lt;p>在設計 web api 時，通常會想要有一個自己系統專用的標準化回應格式，我在前一份工作中因為已經有底層的前輩建立好相關的處理套件，所以一直以來都沒特別研究怎麼包裝以及自訂回應欄位。
&lt;/br>
&lt;/br>
最近在自己的練習專案中嘗試去實作相關機制，才發現原來要考慮的東西有點多，這邊我就來分享一下我的做法以及其他可以用的方式與用途。
&lt;/br>
&lt;/br>&lt;/p></description></item><item><title>C# Feature</title><link>https://yuchia-wei.github.io/2023/02/csharp-feature/</link><pubDate>Sun, 26 Feb 2023 13:35:00 +0800</pubDate><guid>https://yuchia-wei.github.io/2023/02/csharp-feature/</guid><description>&lt;p>以下紀錄一些常用的 C# 語法、特性&lt;/p></description></item></channel></rss>