[{"categories":[],"content":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/"},{"categories":[],"content":"在設計 web api 時，通常會想要有一個自己系統專用的標準化回應格式，我在前一份工作中因為已經有底層的前輩建立好相關的處理套件，所以一直以來都沒特別研究怎麼包裝以及自訂回應欄位。 最近在自己的練習專案中嘗試去實作相關機制，才發現原來要考慮的東西有點多，這邊我就來分享一下我的做法以及其他可以用的方式與用途。 文章預計會分為四個部分，分別為 Part 1 : 包裝 api 回應 Part 2 : 處理例外內容 Part 3 : 其他包裝方法與適用情境 Part 4 : 幫自動化產生的 Swagger Example / Schema 也加上 api response 的內容 這篇是第一部分 「包裝 api 回應」 後續其他部分我會努力趕工!! 資訊 以下內容使用 dotnet 8 的 AspNetCore WebApi 進行測試與開發，相關範例程式碼可以在我的 github repo 找到，但是這個 repo 包含了我許多練習用的程式碼，可能會有點混亂，還請海涵 ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:0:0","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#"},{"categories":[],"content":" 1 定義回應物件","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:1:0","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#定義回應物件"},{"categories":[],"content":" 1.1 標準回應格式既然要建立標準的 api 回應格式，當然是要先準備相關的回應物件。 首先，我們會需要一個 id 來記載這次回應的唯一碼以便支援與追蹤。 除了 id 外，我們可能也會需要紀錄此次 api request 的 api version, request path 等資訊，但由於 api version 通常會設計在 api request path 之上，而 request path 調用的人一定會知道，所以這兩個資訊通常可以忽略，可依據需求選擇是否加入。 實際回應的資料部分，為了讓物件的泛用性更高，選擇泛型來定義資料屬性讓這個回應格式可以相容絕大多數的情境。 csharp /// \u003csummary\u003e /// 標準 api 回應 /// \u003c/summary\u003e /// \u003ctypeparam name=\"T\"\u003e\u003c/typeparam\u003e public class ApiResponse\u003cT\u003e { /// \u003csummary\u003e /// api 的追蹤編號 /// \u003c/summary\u003e public string Id { get; set; } /// \u003csummary\u003e /// api version /// \u003c/summary\u003e public string ApiVersion { get; set; } /// \u003csummary\u003e /// api request path /// \u003c/summary\u003e public string RequestPath { get; set; } /// \u003csummary\u003e /// 回應資料 /// \u003c/summary\u003e public T Data { get; set; } } ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:1:1","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#標準回應格式"},{"categories":[],"content":" 1.2 錯誤資訊物件定義好我們 api 要用的標準回應之後，我們還可以另外準備一個專門用於包裝錯誤資訊的物件，以便我們在系統發生錯誤或者需要自訂回應資訊時另外包裝資料。 通常在建立系統時，為了明確定義錯誤是什麼，在系統設計時都會定義一系列的錯誤碼來告知前端開發人員或 api 使用者我們系統出現了什麼問題，所以這邊我們定義了 ‘ErrorCode’ 屬性來記載錯誤編號 然後，我們可能會另外需要 ‘Message’ 與 ‘Description’ 兩個資訊來分別紀錄「錯誤訊息」與「錯誤詳細資料」。 csharp /// \u003csummary\u003e /// api error information /// \u003c/summary\u003e public class ApiErrorInformation { /// \u003csummary\u003e /// 錯誤編號 /// \u003c/summary\u003e public string ErrorCode { get; set; } /// \u003csummary\u003e /// 錯誤訊息 /// \u003c/summary\u003e public string Message { get; set; } /// \u003csummary\u003e /// 錯誤詳細說明 /// \u003c/summary\u003e [JsonIgnore(Condition = JsonIgnoreCondition.WhenWritingNull)] public string Description { get; set; } } ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:1:2","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#錯誤資訊物件"},{"categories":[],"content":" 2 建立 IResultFilter 處理物件包裝接下來，使用 IResultFilter 來設定系統該如何處理回應物件。 這邊是一個空的 IResultFilter，後面會依據各小節主題持續補充它。 csharp public class SuccessApiResponseWrappingFilter : IResultFilter { /// \u003csummary\u003eCalled before the action result executes.\u003c/summary\u003e /// \u003cparam name=\"context\"\u003eThe \u003csee cref=\"T:Microsoft.AspNetCore.Mvc.Filters.ResultExecutingContext\" /\u003e.\u003c/param\u003e public void OnResultExecuting(ResultExecutingContext context) { throw new NotImplementedException(); } /// \u003csummary\u003eCalled after the action result executes.\u003c/summary\u003e /// \u003cparam name=\"context\"\u003eThe \u003csee cref=\"T:Microsoft.AspNetCore.Mvc.Filters.ResultExecutedContext\" /\u003e.\u003c/param\u003e public void OnResultExecuted(ResultExecutedContext context) { throw new NotImplementedException(); } } ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:0","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#建立-iresultfilter-處理物件包裝"},{"categories":[],"content":" 2.1 避開圖片與大型檔案等回應的包裝當 api 回應的資料是圖片或其他二進位資料時，並不需要去另外包裝為團隊所需的回應格式，因此在自訂的 IResultFilter 中要增加相對應的判斷來避開這個狀況。 在回應圖片或其他二進位資料時，Controller 可能會這樣設定 csharp [HttpGet] public IActionResult GetImage() { var imagePath = \"path_to_image.png\"; var fileBytes = System.IO.File.ReadAllBytes(imagePath); return File(fileBytes, \"image/png\"); } 在這個 api method 中，使用了 File() 來回傳資料，所以在 IResultFilter 中的 context.Result 物件型別會是 FileResult，因此可以判斷 Result 是否為 FileResult 來避開 csharp if (context.Result is FileResult) { return; } 如果要謹慎一點的話，還可以加上資料類型的判斷來避免 context.Result 不是 FileResult 的情境 csharp if (context.Result is FileResult || context.HttpContext.Response.ContentType?.StartsWith(\"image/\") == true || context.HttpContext.Response.ContentType == \"application/octet-stream\") { return; } ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:1","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#避開圖片與大型檔案等回應的包裝"},{"categories":[],"content":" 2.2 包裝有效回應 2.2.1 辨別是否為 200 成功回應如果 Controller 中的 api method 用以下的方式撰寫時，回應的物件分別會是 ‘OkObjectResult’ 、 ‘ObjectResult’ 兩種 csharp [HttpGet(\"action-result\")] public async Task\u003cIActionResult\u003e GetActionResult() { return Ok(\"Hello World\"); } [HttpGet(\"object\")] public async Task\u003cobject\u003e GetObject() { return \"Hello World\"; } 這時候，可以利用以下的判斷來讓 ResultFilter 針對有效回應進行包裝物件；由於我想要自己另外處理錯誤相關的回應，所以這邊是針對 200 的回應來進行包裝，後續會再另外撰寫錯誤資料的包裝行為。 這邊的判斷方法會將轉型好的 ObjectResult 回傳給調用端，讓調用端可以用來設定資料 csharp private static bool TryGetSuccessResultData(ResultExecutingContext context, out ObjectResult successObjectResult) { switch (context.Result) { case OkObjectResult okResult: successObjectResult = okResult; return true; case ObjectResult { StatusCode: \u003e= 200 and \u003c 300 } objectResult: successObjectResult = objectResult; return true; default: successObjectResult = context.Result; return false; } } 2.2.2 包裝回應物件接下來就是實際的物件包裝了，因為前面已經拿到了有效的回應物件，所以這邊的設定就會比較簡單，就只是把 ApiResponse 物件建立起來並設定回去而已。 這邊會比較注意的是，要思考 ApiResponse 中的 Id 欄位要塞入的資料是什麼，在現在可觀測性概念盛行的環境下，我選擇直接使用 Trace Id 來作為我的 Response Id，至於實際上應該要用什麼資料作為 Id 可以由團隊成員一起定義，並且配合資安考量進行處理。 另外，雖然這邊的 successObjectResult 可能為 null，但是我在 TryGetSuccessResultData 中的處理是如果不成功就會是 false，所以並不會進入這個 if 內進行處理，所以我選擇忽略這個問題。 csharp if (TryGetSuccessResultData(context, out var successObjectResult)) { // 從 http header request 中檢查有沒有 trace id // var traceId = context.HttpContext.Request.Headers[\"X-Trace-Id\"].ToString() ?? \"no-trace-id\"; // 利用 dotnet 的 Activity 來取得 trace id var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse\u003cobject?\u003e { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = successObjectResult?.Value }; context.Result = new ObjectResult(wrappedResponse) { Formatters = successObjectResult?.Formatters, ContentTypes = successObjectResult?.ContentTypes, StatusCode = successObjectResult?.StatusCode, DeclaredType = successObjectResult?.DeclaredType, }; } 2.2.3 包裝成品比對 before after ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:2","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#包裝有效回應"},{"categories":[],"content":" 2.2 包裝有效回應 2.2.1 辨別是否為 200 成功回應如果 Controller 中的 api method 用以下的方式撰寫時，回應的物件分別會是 ‘OkObjectResult’ 、 ‘ObjectResult’ 兩種 csharp [HttpGet(\"action-result\")] public async Task GetActionResult() { return Ok(\"Hello World\"); } [HttpGet(\"object\")] public async Task GetObject() { return \"Hello World\"; } 這時候，可以利用以下的判斷來讓 ResultFilter 針對有效回應進行包裝物件；由於我想要自己另外處理錯誤相關的回應，所以這邊是針對 200 的回應來進行包裝，後續會再另外撰寫錯誤資料的包裝行為。 這邊的判斷方法會將轉型好的 ObjectResult 回傳給調用端，讓調用端可以用來設定資料 csharp private static bool TryGetSuccessResultData(ResultExecutingContext context, out ObjectResult successObjectResult) { switch (context.Result) { case OkObjectResult okResult: successObjectResult = okResult; return true; case ObjectResult { StatusCode: \u003e= 200 and \u003c 300 } objectResult: successObjectResult = objectResult; return true; default: successObjectResult = context.Result; return false; } } 2.2.2 包裝回應物件接下來就是實際的物件包裝了，因為前面已經拿到了有效的回應物件，所以這邊的設定就會比較簡單，就只是把 ApiResponse 物件建立起來並設定回去而已。 這邊會比較注意的是，要思考 ApiResponse 中的 Id 欄位要塞入的資料是什麼，在現在可觀測性概念盛行的環境下，我選擇直接使用 Trace Id 來作為我的 Response Id，至於實際上應該要用什麼資料作為 Id 可以由團隊成員一起定義，並且配合資安考量進行處理。 另外，雖然這邊的 successObjectResult 可能為 null，但是我在 TryGetSuccessResultData 中的處理是如果不成功就會是 false，所以並不會進入這個 if 內進行處理，所以我選擇忽略這個問題。 csharp if (TryGetSuccessResultData(context, out var successObjectResult)) { // 從 http header request 中檢查有沒有 trace id // var traceId = context.HttpContext.Request.Headers[\"X-Trace-Id\"].ToString() ?? \"no-trace-id\"; // 利用 dotnet 的 Activity 來取得 trace id var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = successObjectResult?.Value }; context.Result = new ObjectResult(wrappedResponse) { Formatters = successObjectResult?.Formatters, ContentTypes = successObjectResult?.ContentTypes, StatusCode = successObjectResult?.StatusCode, DeclaredType = successObjectResult?.DeclaredType, }; } 2.2.3 包裝成品比對 before after ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:2","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#辨別是否為-200-成功回應"},{"categories":[],"content":" 2.2 包裝有效回應 2.2.1 辨別是否為 200 成功回應如果 Controller 中的 api method 用以下的方式撰寫時，回應的物件分別會是 ‘OkObjectResult’ 、 ‘ObjectResult’ 兩種 csharp [HttpGet(\"action-result\")] public async Task GetActionResult() { return Ok(\"Hello World\"); } [HttpGet(\"object\")] public async Task GetObject() { return \"Hello World\"; } 這時候，可以利用以下的判斷來讓 ResultFilter 針對有效回應進行包裝物件；由於我想要自己另外處理錯誤相關的回應，所以這邊是針對 200 的回應來進行包裝，後續會再另外撰寫錯誤資料的包裝行為。 這邊的判斷方法會將轉型好的 ObjectResult 回傳給調用端，讓調用端可以用來設定資料 csharp private static bool TryGetSuccessResultData(ResultExecutingContext context, out ObjectResult successObjectResult) { switch (context.Result) { case OkObjectResult okResult: successObjectResult = okResult; return true; case ObjectResult { StatusCode: \u003e= 200 and \u003c 300 } objectResult: successObjectResult = objectResult; return true; default: successObjectResult = context.Result; return false; } } 2.2.2 包裝回應物件接下來就是實際的物件包裝了，因為前面已經拿到了有效的回應物件，所以這邊的設定就會比較簡單，就只是把 ApiResponse 物件建立起來並設定回去而已。 這邊會比較注意的是，要思考 ApiResponse 中的 Id 欄位要塞入的資料是什麼，在現在可觀測性概念盛行的環境下，我選擇直接使用 Trace Id 來作為我的 Response Id，至於實際上應該要用什麼資料作為 Id 可以由團隊成員一起定義，並且配合資安考量進行處理。 另外，雖然這邊的 successObjectResult 可能為 null，但是我在 TryGetSuccessResultData 中的處理是如果不成功就會是 false，所以並不會進入這個 if 內進行處理，所以我選擇忽略這個問題。 csharp if (TryGetSuccessResultData(context, out var successObjectResult)) { // 從 http header request 中檢查有沒有 trace id // var traceId = context.HttpContext.Request.Headers[\"X-Trace-Id\"].ToString() ?? \"no-trace-id\"; // 利用 dotnet 的 Activity 來取得 trace id var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = successObjectResult?.Value }; context.Result = new ObjectResult(wrappedResponse) { Formatters = successObjectResult?.Formatters, ContentTypes = successObjectResult?.ContentTypes, StatusCode = successObjectResult?.StatusCode, DeclaredType = successObjectResult?.DeclaredType, }; } 2.2.3 包裝成品比對 before after ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:2","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#包裝回應物件"},{"categories":[],"content":" 2.2 包裝有效回應 2.2.1 辨別是否為 200 成功回應如果 Controller 中的 api method 用以下的方式撰寫時，回應的物件分別會是 ‘OkObjectResult’ 、 ‘ObjectResult’ 兩種 csharp [HttpGet(\"action-result\")] public async Task GetActionResult() { return Ok(\"Hello World\"); } [HttpGet(\"object\")] public async Task GetObject() { return \"Hello World\"; } 這時候，可以利用以下的判斷來讓 ResultFilter 針對有效回應進行包裝物件；由於我想要自己另外處理錯誤相關的回應，所以這邊是針對 200 的回應來進行包裝，後續會再另外撰寫錯誤資料的包裝行為。 這邊的判斷方法會將轉型好的 ObjectResult 回傳給調用端，讓調用端可以用來設定資料 csharp private static bool TryGetSuccessResultData(ResultExecutingContext context, out ObjectResult successObjectResult) { switch (context.Result) { case OkObjectResult okResult: successObjectResult = okResult; return true; case ObjectResult { StatusCode: \u003e= 200 and \u003c 300 } objectResult: successObjectResult = objectResult; return true; default: successObjectResult = context.Result; return false; } } 2.2.2 包裝回應物件接下來就是實際的物件包裝了，因為前面已經拿到了有效的回應物件，所以這邊的設定就會比較簡單，就只是把 ApiResponse 物件建立起來並設定回去而已。 這邊會比較注意的是，要思考 ApiResponse 中的 Id 欄位要塞入的資料是什麼，在現在可觀測性概念盛行的環境下，我選擇直接使用 Trace Id 來作為我的 Response Id，至於實際上應該要用什麼資料作為 Id 可以由團隊成員一起定義，並且配合資安考量進行處理。 另外，雖然這邊的 successObjectResult 可能為 null，但是我在 TryGetSuccessResultData 中的處理是如果不成功就會是 false，所以並不會進入這個 if 內進行處理，所以我選擇忽略這個問題。 csharp if (TryGetSuccessResultData(context, out var successObjectResult)) { // 從 http header request 中檢查有沒有 trace id // var traceId = context.HttpContext.Request.Headers[\"X-Trace-Id\"].ToString() ?? \"no-trace-id\"; // 利用 dotnet 的 Activity 來取得 trace id var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = successObjectResult?.Value }; context.Result = new ObjectResult(wrappedResponse) { Formatters = successObjectResult?.Formatters, ContentTypes = successObjectResult?.ContentTypes, StatusCode = successObjectResult?.StatusCode, DeclaredType = successObjectResult?.DeclaredType, }; } 2.2.3 包裝成品比對 before after ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:2","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#包裝成品比對"},{"categories":[],"content":" 2.3 處理錯誤回應前面處理完了成功的回應後，接下來接著處理錯誤的回應。 2.3.1 辨別是否為 400 錯誤回應為了針對錯誤要求進行包裝，這邊一樣使用一個判斷方法來辨別是否為 BadRequestResult csharp private static bool TryGetBadRequestResultData(ResultExecutingContext context, out BadRequestResult? badRequestResult) { if (context.Result is BadRequestResult result) { badRequestResult = result; return true; } badRequestResult = null; return false; } 2.3.2 包裝回應物件接著來處理回應物件包裝的部分，這邊會需要注意的點是，開發團隊可能使用 FluentValidation 進行物件驗證，也可能使用內建的 DataAnnotations 進行驗證，兩邊回應的物件不一樣，所以會需要注意物件轉換時所使用的物件。 先將 FluentValidation 跟 DataAnnotations 的錯誤物件轉為前面定義的共用錯誤物件 ‘ApiErrorInformation’，這邊的範例程式碼的設定方式僅用於示意，實際的設定方法應與團隊協議好物件該怎麼定義資料。 資訊 當然，如果團隊有共識可以直接使用原本的錯誤物件輸出也是沒有問題的，完全就是團隊在系統設計上的決策問題~ 如果要使用原本的錯誤物件，做法就跟前面成功要求的做法一樣，直接把回應資料包起來就好，不用特別處理。 csharp var apiErrorInformation = new ApiErrorInformation(); switch (badRequestObjectResult.Value) { // FluentValidation 的錯誤物件 case List\u003cValidationFailure\u003e validationFailures: apiErrorInformation.ErrorCode = validationFailures.First().ErrorCode; apiErrorInformation.Message = validationFailures.First().ErrorMessage; break; // DataAnnotations 的錯誤物件 case ValidationProblemDetails validationProblemDetails: apiErrorInformation.ErrorCode = validationProblemDetails.Title; // 這邊需要額外進入 values 裡面才能取得真的要的錯誤訊息 apiErrorInformation.Message = validationProblemDetails.Errors.Values.FirstOrDefault().FirstOrDefault(); break; } 再來跟前面成功的回應一樣，設定 Result csharp var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse\u003cApiErrorInformation\u003e { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = apiErrorInformation }; context.Result = new BadRequestObjectResult(wrappedResponse) { Formatters = badRequestObjectResult.Formatters, ContentTypes = badRequestObjectResult.ContentTypes, StatusCode = badRequestObjectResult.StatusCode, DeclaredType = badRequestObjectResult.DeclaredType }; 2.3.3 包裝後成果 use data annotations validation use fluent validation ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:3","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#處理錯誤回應"},{"categories":[],"content":" 2.3 處理錯誤回應前面處理完了成功的回應後，接下來接著處理錯誤的回應。 2.3.1 辨別是否為 400 錯誤回應為了針對錯誤要求進行包裝，這邊一樣使用一個判斷方法來辨別是否為 BadRequestResult csharp private static bool TryGetBadRequestResultData(ResultExecutingContext context, out BadRequestResult? badRequestResult) { if (context.Result is BadRequestResult result) { badRequestResult = result; return true; } badRequestResult = null; return false; } 2.3.2 包裝回應物件接著來處理回應物件包裝的部分，這邊會需要注意的點是，開發團隊可能使用 FluentValidation 進行物件驗證，也可能使用內建的 DataAnnotations 進行驗證，兩邊回應的物件不一樣，所以會需要注意物件轉換時所使用的物件。 先將 FluentValidation 跟 DataAnnotations 的錯誤物件轉為前面定義的共用錯誤物件 ‘ApiErrorInformation’，這邊的範例程式碼的設定方式僅用於示意，實際的設定方法應與團隊協議好物件該怎麼定義資料。 資訊 當然，如果團隊有共識可以直接使用原本的錯誤物件輸出也是沒有問題的，完全就是團隊在系統設計上的決策問題~ 如果要使用原本的錯誤物件，做法就跟前面成功要求的做法一樣，直接把回應資料包起來就好，不用特別處理。 csharp var apiErrorInformation = new ApiErrorInformation(); switch (badRequestObjectResult.Value) { // FluentValidation 的錯誤物件 case List validationFailures: apiErrorInformation.ErrorCode = validationFailures.First().ErrorCode; apiErrorInformation.Message = validationFailures.First().ErrorMessage; break; // DataAnnotations 的錯誤物件 case ValidationProblemDetails validationProblemDetails: apiErrorInformation.ErrorCode = validationProblemDetails.Title; // 這邊需要額外進入 values 裡面才能取得真的要的錯誤訊息 apiErrorInformation.Message = validationProblemDetails.Errors.Values.FirstOrDefault().FirstOrDefault(); break; } 再來跟前面成功的回應一樣，設定 Result csharp var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = apiErrorInformation }; context.Result = new BadRequestObjectResult(wrappedResponse) { Formatters = badRequestObjectResult.Formatters, ContentTypes = badRequestObjectResult.ContentTypes, StatusCode = badRequestObjectResult.StatusCode, DeclaredType = badRequestObjectResult.DeclaredType }; 2.3.3 包裝後成果 use data annotations validation use fluent validation ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:3","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#辨別是否為-400-錯誤回應"},{"categories":[],"content":" 2.3 處理錯誤回應前面處理完了成功的回應後，接下來接著處理錯誤的回應。 2.3.1 辨別是否為 400 錯誤回應為了針對錯誤要求進行包裝，這邊一樣使用一個判斷方法來辨別是否為 BadRequestResult csharp private static bool TryGetBadRequestResultData(ResultExecutingContext context, out BadRequestResult? badRequestResult) { if (context.Result is BadRequestResult result) { badRequestResult = result; return true; } badRequestResult = null; return false; } 2.3.2 包裝回應物件接著來處理回應物件包裝的部分，這邊會需要注意的點是，開發團隊可能使用 FluentValidation 進行物件驗證，也可能使用內建的 DataAnnotations 進行驗證，兩邊回應的物件不一樣，所以會需要注意物件轉換時所使用的物件。 先將 FluentValidation 跟 DataAnnotations 的錯誤物件轉為前面定義的共用錯誤物件 ‘ApiErrorInformation’，這邊的範例程式碼的設定方式僅用於示意，實際的設定方法應與團隊協議好物件該怎麼定義資料。 資訊 當然，如果團隊有共識可以直接使用原本的錯誤物件輸出也是沒有問題的，完全就是團隊在系統設計上的決策問題~ 如果要使用原本的錯誤物件，做法就跟前面成功要求的做法一樣，直接把回應資料包起來就好，不用特別處理。 csharp var apiErrorInformation = new ApiErrorInformation(); switch (badRequestObjectResult.Value) { // FluentValidation 的錯誤物件 case List validationFailures: apiErrorInformation.ErrorCode = validationFailures.First().ErrorCode; apiErrorInformation.Message = validationFailures.First().ErrorMessage; break; // DataAnnotations 的錯誤物件 case ValidationProblemDetails validationProblemDetails: apiErrorInformation.ErrorCode = validationProblemDetails.Title; // 這邊需要額外進入 values 裡面才能取得真的要的錯誤訊息 apiErrorInformation.Message = validationProblemDetails.Errors.Values.FirstOrDefault().FirstOrDefault(); break; } 再來跟前面成功的回應一樣，設定 Result csharp var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = apiErrorInformation }; context.Result = new BadRequestObjectResult(wrappedResponse) { Formatters = badRequestObjectResult.Formatters, ContentTypes = badRequestObjectResult.ContentTypes, StatusCode = badRequestObjectResult.StatusCode, DeclaredType = badRequestObjectResult.DeclaredType }; 2.3.3 包裝後成果 use data annotations validation use fluent validation ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:3","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#包裝回應物件-1"},{"categories":[],"content":" 2.3 處理錯誤回應前面處理完了成功的回應後，接下來接著處理錯誤的回應。 2.3.1 辨別是否為 400 錯誤回應為了針對錯誤要求進行包裝，這邊一樣使用一個判斷方法來辨別是否為 BadRequestResult csharp private static bool TryGetBadRequestResultData(ResultExecutingContext context, out BadRequestResult? badRequestResult) { if (context.Result is BadRequestResult result) { badRequestResult = result; return true; } badRequestResult = null; return false; } 2.3.2 包裝回應物件接著來處理回應物件包裝的部分，這邊會需要注意的點是，開發團隊可能使用 FluentValidation 進行物件驗證，也可能使用內建的 DataAnnotations 進行驗證，兩邊回應的物件不一樣，所以會需要注意物件轉換時所使用的物件。 先將 FluentValidation 跟 DataAnnotations 的錯誤物件轉為前面定義的共用錯誤物件 ‘ApiErrorInformation’，這邊的範例程式碼的設定方式僅用於示意，實際的設定方法應與團隊協議好物件該怎麼定義資料。 資訊 當然，如果團隊有共識可以直接使用原本的錯誤物件輸出也是沒有問題的，完全就是團隊在系統設計上的決策問題~ 如果要使用原本的錯誤物件，做法就跟前面成功要求的做法一樣，直接把回應資料包起來就好，不用特別處理。 csharp var apiErrorInformation = new ApiErrorInformation(); switch (badRequestObjectResult.Value) { // FluentValidation 的錯誤物件 case List validationFailures: apiErrorInformation.ErrorCode = validationFailures.First().ErrorCode; apiErrorInformation.Message = validationFailures.First().ErrorMessage; break; // DataAnnotations 的錯誤物件 case ValidationProblemDetails validationProblemDetails: apiErrorInformation.ErrorCode = validationProblemDetails.Title; // 這邊需要額外進入 values 裡面才能取得真的要的錯誤訊息 apiErrorInformation.Message = validationProblemDetails.Errors.Values.FirstOrDefault().FirstOrDefault(); break; } 再來跟前面成功的回應一樣，設定 Result csharp var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = apiErrorInformation }; context.Result = new BadRequestObjectResult(wrappedResponse) { Formatters = badRequestObjectResult.Formatters, ContentTypes = badRequestObjectResult.ContentTypes, StatusCode = badRequestObjectResult.StatusCode, DeclaredType = badRequestObjectResult.DeclaredType }; 2.3.3 包裝後成果 use data annotations validation use fluent validation ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:3","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#包裝後成果"},{"categories":[],"content":" 2.4 完整的 Api Response Wrapping Filter csharp /// \u003csummary\u003e /// api 回應包裝器 /// \u003c/summary\u003e public class ApiResponseWrappingFilter : IResultFilter { public void OnResultExecuting(ResultExecutingContext context) { if (IsBinaryResult(context)) { return; } if (TryGetSuccessResultData(context, out var successObjectResult)) { // var traceId = context.HttpContext.Request.Headers[\"X-Trace-Id\"].ToString() ?? \"no-trace-id\"; var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse\u003cobject?\u003e { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = successObjectResult?.Value }; context.Result = new ObjectResult(wrappedResponse) { Formatters = successObjectResult?.Formatters, ContentTypes = successObjectResult?.ContentTypes, StatusCode = successObjectResult?.StatusCode, DeclaredType = successObjectResult?.DeclaredType }; } if (TryGetBadRequestObjectResultData(context, out var badRequestObjectResult)) { var apiErrorInformation = new ApiErrorInformation(); switch (badRequestObjectResult.Value) { // FluentValidation 的錯誤物件 case List\u003cValidationFailure\u003e validationFailures: apiErrorInformation.ErrorCode = validationFailures.First().ErrorCode; apiErrorInformation.Message = validationFailures.First().ErrorMessage; break; // DataAnnotations 的錯誤物件 case ValidationProblemDetails validationProblemDetails: apiErrorInformation.ErrorCode = validationProblemDetails.Title; // 這邊需要額外進入 values 裡面才能取得真的要的錯誤訊息 apiErrorInformation.Message = validationProblemDetails.Errors.Values.FirstOrDefault().FirstOrDefault(); break; case ApiErrorInformation apiError: apiErrorInformation = apiError; break; } var traceId = Activity.Current?.TraceId.ToString() ?? Guid.NewGuid().ToString(); var wrappedResponse = new ApiResponse\u003cApiErrorInformation\u003e { Id = traceId, ApiVersion = context.HttpContext.ApiVersioningFeature().RawRequestedApiVersion, RequestPath = $\"{context.HttpContext.Request.Path}.{context.HttpContext.Request.Method}\", Data = apiErrorInformation }; context.Result = new BadRequestObjectResult(wrappedResponse) { Formatters = badRequestObjectResult.Formatters, ContentTypes = badRequestObjectResult.ContentTypes, StatusCode = badRequestObjectResult.StatusCode, DeclaredType = badRequestObjectResult.DeclaredType }; } } public void OnResultExecuted(ResultExecutedContext context) { // 這裡可以加入在結果執行後的處理邏輯 } private static bool IsBinaryResult(ResultExecutingContext context) { return context.Result is FileResult || context.HttpContext.Response.ContentType?.StartsWith(\"image/\") == true || context.HttpContext.Response.ContentType == \"application/octet-stream\"; } private static bool TryGetBadRequestObjectResultData(ResultExecutingContext context, out BadRequestObjectResult? badRequestResult) { if (context.Result is BadRequestObjectResult result) { badRequestResult = result; return true; } badRequestResult = null; return false; } private static bool TryGetSuccessResultData(ResultExecutingContext context, out ObjectResult? successObjectResult) { switch (context.Result) { case OkObjectResult okResult: successObjectResult = okResult; return true; case ObjectResult { StatusCode: \u003e= 200 and \u003c 300 } objectResult: successObjectResult = objectResult; return true; default: successObjectResult = null; return false; } } } ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:4","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#完整的-api-response-wrapping-filter"},{"categories":[],"content":" 2.5 補充資料 ActionFilter \u0026 ResultFilter在前面可以看到我使用的是 IResultFilter 來包裝回應物件，這是因為 IResultFilter 是專門用來處理回應和修改 IActionResult 用的介面，他分別有 OnResultExecuting 與 OnResultExecuted 兩個方法，個別的職責如下 OnResultExecuting 在動作方法執行完並生成結果，但在結果被處理（例如序列化成 JSON 或其他格式）之前執行。 你可以在這裡修改 ActionResult，或者執行額外的邏輯，譬如我們這邊做的包裝回應物件，又或者是手動調整 Http Status Code 等。 OnResultExecuted 在結果已經處理完，回應即將發送給客戶端之後執行。 這個方法主要用於在結果已經準備發送給客戶端後做一些清理操作或記錄日誌。 詳細資料可以參考 MS Learn ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:2:5","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#補充資料-actionfilter--resultfilter"},{"categories":[],"content":" 3 為 Controller 加上 IResultFilter在完成了前面的物件準備後，當然就是要套用在系統上拉~ 套用的方式很簡單，只需要在 program.cs 的 controller 設定裡加上去就好了，程式碼如下 csharp builder.Services.AddControllers(options =\u003e { options.Filters.Add\u003cApiResponseWrappingFilter\u003e(); }); murmur: 發現寫長文的時候現在使用的佈景會有些問題，字體感覺也不夠大，我要再找一下有沒有其他適用的布景，或是也要整理一下內容貼到其他 blog 平台了 在實作 web api 時，通常都會另外處理自己系統專屬的回應物件，我在前一份工作中因為已經有底層的前輩建立好相關的處理套件，所以一直以來都沒特別研究怎麼包裝以及自訂回應欄位。 ","date":"2024-10-12","objectID":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/:3:0","series":["aspnetcore-webapi-custom-response-model"],"tags":["dotnet"],"title":"幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應","uri":"/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/#為-controller-加上-iresultfilter"},{"categories":[],"content":"該使用 SDK 還是 WebApi 的形式提供服務?","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/"},{"categories":[],"content":"大家在使用 dotnet 或其他可以打包成功開套件做分享的程式語言時，可能都會想到一個問題 現在 WebApi 那麼盛行，我該如何抉擇要使用 Web Api 還是 套件 的形式發布我的服務、功能呢？ 我覺得我新寫的功能好棒棒，我想發布成 nuget package 分享給團隊，但是不確定合不合適 這邊我簡單梳理一下一些需要考量的點~ 備註1: 這篇算是過往前輩教我的一些心法整理，配合我自己後續的開發經驗所整理的一些小資訊 備註2: 由於我主要還是開發 dotnet 的服務，因此以下都會以 dotnet 的角度出發 ","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:0:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#"},{"categories":[],"content":" 套件的開發評估","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:0:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#套件的開發評估"},{"categories":[],"content":" 1 誰適合使用開發套件的方式發布 簡單的邏輯運算 簡單的資料組合 盡可能只倚賴微軟套件或常見的主流套件，並且會跟著相依套件進行更版 提供的功能單一，且有高內聚特性 當套件更新時，使用此套件的應用程式不需要即時更新也能維持功能不出錯 提供對特定版本的 WebApi 或 資料庫 連線與調用功能的能力 ","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:1:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#誰適合使用開發套件的方式發布"},{"categories":[],"content":" 2 Nuget 套件開發時的注意事項 不要依賴太多外部套件 (除非是要做那個套件的額外擴充) 盡量不要有網路以外的 IO 處理 (會允許網路 IO 是要與 API 溝通) 若使用者不使用你的套件，應該也要有相對簡單的方式達成一樣的目的 套件提供的功能應該要有高內聚、低耦合的特性 套件的 API 設計要簡單明瞭，且職責明確 盡可能提供有彈性的注入方法 最好提供專用的注入方法，避免內部實作物件暴露 一定要有公開介面 內部實作可以的話不要使用 public ","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:2:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#nuget-套件開發時的注意事項"},{"categories":[],"content":" Web Api 的開發評估","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:0:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#web-api-的開發評估"},{"categories":[],"content":" 1 誰適合製作 WebApi 需要獨立運作 需要頻繁與資料庫互動 需要處理複雜邏輯 需要更新後能夠立即反映新的邏輯在使用此 Web Api 的系統 需要同時提供多版本功能 除了 dotnet 系統外，也需要提供服務給前端等非 dotnet 生態系的系統 ","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:1:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#誰適合製作-webapi"},{"categories":[],"content":" 其他參考資料 安德魯的部落格-API \u0026 SDK Design #2, 設計專屬的 SDK ","date":"2024-03-03","objectID":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/:0:0","series":[],"tags":[],"title":"該使用 SDK 還是 WebApi 的形式提供服務?","uri":"/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/#其他參考資料"},{"categories":[],"content":"我初期在公司建立地端 Kubernetes 叢集以進行 POC 時，都是使用 kubeadm 這套官方工具進行的 (我早期文章就是基於此撰寫的)。 但是當需要將 Kubernetes 拓展到其他單位時，那相對複雜的安裝與管理方式卻是第一個難以躍過的門檻。 因此，後續改用 RKE2 建立，並且導入 Rancher 進行 Kubernetes 叢集管理。從 2022 年末使用至今，由於我們公司的運用情境相對簡單，因此沒出現太多難以處理的問題。 這篇紀錄我的 RKE2 + Rancher 的安裝命令，主要內容都是依據 iThome Kubernetes Summit 2022 時我參與的 SUSE 工作坊講師提供的資訊進行調整，並適度的加上一些說明。 ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:0:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#"},{"categories":[],"content":" RKE2 Install","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:0:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#rke2-install"},{"categories":[],"content":" 1 運作環境 資訊 OS Ubuntu 20.04 RKE2 v1.24.11+rke2r1 應配合 Rancher 選擇版本 Rancher v2.7.9 應配合 RKE2 選擇版本 ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:1:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#運作環境"},{"categories":[],"content":" 2 First Node","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#first-node"},{"categories":[],"content":" 2.1 download rke2 install file bash #預設不給 type 就是 server 了，所以不用特地給 type #curl -sfL https://get.rke2.io | INSTALL_RKE2_TYPE=\"server\" sh - curl -sfL https://get.rke2.io --output install.sh chmod +x install.sh ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:1","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#download-rke2-install-file"},{"categories":[],"content":" 2.2 Create RKE2 Config bash sudo mkdir -p /etc/rancher/rke2/ cat \u003c\u003cEOF | sudo tee /etc/rancher/rke2/config.yaml # 主機名稱 node-name: - \"rke2-node-01\" # k8s 各主機溝通用的憑證簽章 tls-san: - rke2-node-01 # node host - rke2-node-01.local.vm # node host domain - rke2-cluster.local.vm # k8s cluster api server domain - 1.1.1.1 # k8s cluster api server domain 的 vip，看參考資料多半都有設定 #如果要做純 k8s master 的話可已加入以下設定，RKE2 預設是混合 NODE #node-taint: # - \"CriticalAddinsonly=true:NoExecute\" #以下參數所有 master node 都要相同 # 由於我的環境主要使用 istio，因此關掉 nginx 的 ingress disable: rke2-ingress-nginx cni: - cilium EOF ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:2","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#create-rke2-config"},{"categories":[],"content":" 2.3 Run Install bash sudo INSTALL_RKE2_CHANNEL=v1.24.11+rke2r1 ./install.sh export PATH=$PATH:/opt/rke2/bin sudo systemctl enable rke2-server #這邊執行後會要等一下 sudo systemctl start rke2-server ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:3","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#run-install"},{"categories":[],"content":" 2.4 Set Config and Kubectl bash mkdir .kube sudo cp /etc/rancher/rke2/rke2.yaml .kube/config #如果不是用 root 登入的話，需要另外給予權限 #sudo chown rancher .kube/config sudo cp /var/lib/rancher/rke2/bin/kubectl /usr/local/bin/ ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:4","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#set-config-and-kubectl"},{"categories":[],"content":" 2.5 Get rke2 token 資訊 這邊是用來給其他 Master Node 用的，如果只打算建立一台 Master Node，則可以忽略此步驟 bash sudo cat /var/lib/rancher/rke2/server/token ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:5","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#get-rke2-token"},{"categories":[],"content":" 3 Other Master Node 資訊 基本流程大致一樣，只有 config 會有些許差異，因此此節僅保留差異處 ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:3:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#other-master-node"},{"categories":[],"content":" 3.1 Create rke2 Config 資訊 config 最大的差異是在第二台以後的 master 都需要加上 token / server 等欄位 bash sudo mkdir -p /etc/rancher/rke2/ cat \u003c\u003cEOF | sudo tee /etc/rancher/rke2/config.yaml token: -- #這邊 server 有人用第一台主機的 domain，有人用叢集 domain，只要能連上主要的 master 主機並使用 9345 port 即可 #port 的部分 RKE2 預設使用 9345，但是仍有開通 6443 來供一般使用 server: https://rke2-node-01.local.vm:9345 # 主機名稱 node-name: - \"rke2-node-02\" # k8s 各主機溝通用的憑證簽章 tls-san: - rke2-node-02 # node host - rke2-node-02.local.vm # node host domain - rke2-cluster.local.vm # k8s cluster api server domain - 1.1.1.1 # k8s cluster api server domain 的 vip，看參考資料多半都有設定 #如果要做純 k8s master 的話可已加入以下設定，RKE2 預設是混合 NODE #node-taint: # - \"CriticalAddinsonly=true:NoExecute\" #以下參數所有 master node 都要相同 # 由於我的環境主要使用 istio，因此關掉 nginx 的 ingress disable: rke2-ingress-nginx cni: - cilium EOF ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:3:1","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#create-rke2-config-1"},{"categories":[],"content":" 4 uninstall 官方解安裝文件 ubuntu 直接執行 /usr/local/bin/rke2-uninstall.sh 就好，輕鬆愜意，會把所有自訂設定等資料全部清空，所以設定檔記得留備份 centos 直接執行 /usr/bin/rke2-uninstall.sh 就好，輕鬆愜意，會把所有自訂設定等資料全部清空，所以設定檔記得留備份 ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:4:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#uninstall"},{"categories":[],"content":" Istio / Rancher 等其他服務安裝 資訊 由於後續的操作都會需要連上 kubernetes，因此請記得運用 Set Config and Kubectl 章節中的命令將工具與設定檔抓出來 ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:0:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#istio--rancher-等其他服務安裝"},{"categories":[],"content":" 1 Helm bash curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:1:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#helm"},{"categories":[],"content":" 2 Helm Repo bash helm repo add istio https://istio-release.storage.googleapis.com/charts helm repo add rancher-stable https://releases.rancher.com/server-charts/stable helm repo add jetstack https://charts.jetstack.io helm repo update ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:2:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#helm-repo"},{"categories":[],"content":" 3 istio 資訊 這邊只安裝 istio 的基礎工具，ingress 以及其他配合 rancher 的設定會跟 rancher 的安裝一起進行 bash kubectl create namespace istio-system helm install istio-base istio/base -n istio-system --wait helm install istiod istio/istiod -n istio-system --wait ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:3:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#istio"},{"categories":[],"content":" 4 cert-manager 資訊 rancher latest version doc rancher 官方有說明目前最新版本對於 cert-manager 的版本測試狀況，可依據自己的需求進行相關版本調整 如果網路環境有硬體可以處理外部憑證，可以忽略此套件的安裝，並且在安裝 rancher 時使用外部憑證 (並搭配無憑證設定的 istio ingress) bash kubectl apply -f https://github.com/cert-manager/cert-manager/releases/download/v1.7.1/cert-manager.crds.yaml helm install cert-manager jetstack/cert-manager --namespace cert-manager --create-namespace --version v1.7.1 --wait ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:4:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#cert-manager"},{"categories":[],"content":" 5 rancher 資訊 這邊配合前面安裝的 RKE2 版本而使用 2.7.9 的 Rancher ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:5:0","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#rancher"},{"categories":[],"content":" 5.1 basic install bash kubectl create namespace cattle-system helm install rancher rancher-stable/rancher --namespace cattle-system --set hostname=my-rancher.local.vm --version 2.7.9 # use external tls # helm install rancher rancher-stable/rancher --namespace cattle-system --set hostname=my-rancher.local.vm --version 2.7.9 --set external-tls ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:5:1","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#basic-install"},{"categories":[],"content":" 5.2 set istio bash helm install istio-ingressgateway istio/gateway -n cattle-system --wait sudo mkdir -p ~/istio-setting cat \u003c\u003cEOF | sudo tee ~/istio-setting/gateway.yaml apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: rancher-gateway namespace: cattle-system spec: selector: istio: ingressgateway servers: - hosts: - my-rancher.local.vm port: name: http number: 80 protocol: HTTP # 如果是使用外部憑證的話，這邊設定可以省去或是要另外調整 - port: number: 443 name: https-443 protocol: HTTPS hosts: - my-rancher.local.vm tls: # mode: PASSTHROUGH mode: SIMPLE credentialName: cattle-system/tls-rancher-ingress EOF cat \u003c\u003cEOF | sudo tee ~/istio-setting/virtualservice.yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: rancher-vs namespace: cattle-system spec: gateways: - rancher-gateway hosts: - my-rancher.local.vm http: - headers: request: set: x-forwarded-proto: https route: - destination: host: rancher.cattle-system.svc.cluster.local port: number: 80 # 如果是使用外部憑證的話，這邊設定可以省去或是要另外調整 tls: - match: - port: 443 sniHosts: - my-rancher.local.vm route: - destination: host: rancher.cattle-system.svc.cluster.local port: number: 443 EOF kubectl apply -f ./ ","date":"2024-01-28","objectID":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/:5:2","series":[],"tags":[],"title":"建立 RKE2 叢集並且安裝 Rancher / istio","uri":"/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/#set-istio"},{"categories":[],"content":"今天是 2023 年的最後一天，趁著今年還沒結束，來回顧一下我在今年的技術發展狀況吧~ 不過，因為這一年都沒怎麼寫 blog (都靠 hackmd 紀錄筆記)，希望不要不小心把去年的事情寫成今年 XD ","date":"2023-12-31","objectID":"/2023/12/2023-yearly-retrospective/:0:0","series":["Yearly-Retrospective"],"tags":[],"title":"2023 年度回顧","uri":"/2023/12/2023-yearly-retrospective/#"},{"categories":[],"content":" 2023 年回顧","date":"2023-12-31","objectID":"/2023/12/2023-yearly-retrospective/:0:0","series":["Yearly-Retrospective"],"tags":[],"title":"2023 年度回顧","uri":"/2023/12/2023-yearly-retrospective/#2023-年回顧"},{"categories":[],"content":" 1 社群參與今年依然參與了一堆社群活動，去年還特別將參加者名牌拍起來，今年…… 都不知道被我收去哪了 XD 會議部分，iThome 的 SRE Conf, Agile Conf, DevOps Conf, Kubernetes Conf 算是這幾年開始會跑的活動，今年也另外參加了幾次 DevOps Taiwan Meetup。 其他像是 DDD Conf, .Net Conf Taiwan 以及 COSCUP 當然也是要去，不過 COSCUP 因為有一天撞到公司活動，只能去一天有點可惜。 今年在這些活動中可以發現，服務的可觀測性在今年整個大爆發，到處都在說，主題也一堆。 DevOps 延續去年的 BizDevOps，今年也有一些場次，不過不知道是不是因為跟技術差太遠，感覺討論沒有很熱烈……。 不過比起前面的技術場次，今年參加最特別的活動絕對是 科技工作講 這個 podcast 主持人所舉辦的 科技菁英年終盛會，拓展了不少視野~ ","date":"2023-12-31","objectID":"/2023/12/2023-yearly-retrospective/:1:0","series":["Yearly-Retrospective"],"tags":[],"title":"2023 年度回顧","uri":"/2023/12/2023-yearly-retrospective/#社群參與"},{"categories":[],"content":" 2 職場發展今年在公司的發展感覺沒像 2022 一樣都圍繞在 kubernetes 的安裝應用，又有開始回去服務改善以及專案進行的部分。 開始在學習 DDD 以及六角架構，並且應用到公司的系統、軟體架構上，不過為了要讓其他人可以相對容易理解不同架構的相似處，導致整個專案架構很四不像……感覺很差。 在可觀測性方面，也把 Open Telemetry 的自動追蹤搞起來了，幫公司建立了共用的基礎容器，免得每個專案都需要手工安裝 open telemetry 的套件，應該算是一大改善？配合 Grafana 的 Tempo / Loki，算是解決了容器化後很多資訊都相對不易查詢的問題。 而且也在年中跟其他單位一起合作把 ELK 建起來了，雖然…… 現在還只是個資料很多的蚊子館 XD。 年底當然不意外地跟著 .net 8 的推出進行了部分服務的更新，依然是無痛 (?) 升級，除了因為 OpenSSL 版本升級後，為了相容公司網路又有做了一些調整。 這幾個月也幫公司把該做的文件跟範本弄起來了，雖然應該也沒人看……。 也用了 RabbitMQ 幫新專案試行了 MQ 形式的工作處理，希望這個架構對其他同事來說不會太過困難。 明年度也許會把重心放在敏捷的運用上？ ","date":"2023-12-31","objectID":"/2023/12/2023-yearly-retrospective/:2:0","series":["Yearly-Retrospective"],"tags":[],"title":"2023 年度回顧","uri":"/2023/12/2023-yearly-retrospective/#職場發展"},{"categories":[],"content":" 3 自學今年度又另外去報了 Odd-e 的敏捷相關課程，算是體會到了些敏捷的運用，不過要怎麼運用到職場上……還有很大段路要走。 ","date":"2023-12-31","objectID":"/2023/12/2023-yearly-retrospective/:3:0","series":["Yearly-Retrospective"],"tags":[],"title":"2023 年度回顧","uri":"/2023/12/2023-yearly-retrospective/#自學"},{"categories":["Development-Tools"],"content":"JetBrains Rider 常用擴充套件","date":"2023-12-17","objectID":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/","series":[],"tags":["extensions","jetBrains-rider"],"title":"JetBrains Rider 常用擴充套件","uri":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/"},{"categories":["Development-Tools"],"content":" JetBrian Rider Extensions以下套件除非是特定語言專用，不然皆通用於 JetBrian 的 IDE，而 Rider 可用的套件多數都擁有 ReSharper 版本可供使用。 ","date":"2023-12-17","objectID":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","jetBrains-rider"],"title":"JetBrains Rider 常用擴充套件","uri":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/#jetbrian-rider-extensions"},{"categories":["Development-Tools"],"content":" 1 推薦安裝 AceJump 游標移動的輔助工具，可以快速地將游標移動到特定位置 建議安裝 GitHub CognitiveComplexity 檢視程式碼複雜度 建議安裝 GitHub Heap Allocations Viewer 檢視變數是否有 Boxing/Unboxing issue 建議安裝 GitHub AsyncApostle AsyncConverter 的 Fork，因 AsyncConverter 的更新一直落後於 JetBrains IDE，因此有其他人 Fork 出來進行維護 快速轉換同步、非同步方法 GitHub NSubstituteComplete 在單元測試中，快速完成使用 NSubstitute 的部分 GitHub Rainbow Brackets 幫程式碼中的左右括號、中括號、大括號等字元上色，方便檢視對應的符號位置 付費工具 GitHub ","date":"2023-12-17","objectID":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/:1:0","series":[],"tags":["extensions","jetBrains-rider"],"title":"JetBrains Rider 常用擴充套件","uri":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/#推薦安裝"},{"categories":["Development-Tools"],"content":" 2 推薦學習與安裝 ideaVim 讓 Rider (所有 JetBrains IDE) 支援 VIM GitHub ","date":"2023-12-17","objectID":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/:2:0","series":[],"tags":["extensions","jetBrains-rider"],"title":"JetBrains Rider 常用擴充套件","uri":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/#推薦學習與安裝"},{"categories":["Development-Tools"],"content":" 3 若有需要可考慮安裝 FluentAssertions 快速完成單完測試的驗證 (使用 FluentAssertions) GitHub FluentValidation Nuget FluentValidation 的輔助工具 GitHub ","date":"2023-12-17","objectID":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/:3:0","series":[],"tags":["extensions","jetBrains-rider"],"title":"JetBrains Rider 常用擴充套件","uri":"/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/#若有需要可考慮安裝"},{"categories":["software-development"],"content":"程式碼重構 - 基本概念","date":"2023-12-17","objectID":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/","series":["code-refactor"],"tags":["refactor"],"title":"程式碼重構 - 基本概念","uri":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/"},{"categories":["software-development"],"content":"重構：在不影響程式碼邏輯的前提下進行程式碼修改的行為 重構行為應使用 IDE 隨附的重構命令處理，以降低人為操作的錯誤，且盡可能在進行重構前加入測試，避免重構後發生錯誤。 本文記錄我過往經驗中，對於重構的一些想法與概念，也有在上課後老師所提供的想法。 ","date":"2023-12-17","objectID":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:0","series":["code-refactor"],"tags":["refactor"],"title":"程式碼重構 - 基本概念","uri":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#"},{"categories":["software-development"],"content":" 程式碼重構的基本概念","date":"2023-12-17","objectID":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:0:0","series":["code-refactor"],"tags":["refactor"],"title":"程式碼重構 - 基本概念","uri":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#程式碼重構的基本概念"},{"categories":["software-development"],"content":" 1 在重構之前如果架構允許，應替重構目標加入測試，以避免重構後的功能邏輯與重構前不同的問題。 若對外部類別的依賴過高，導致無法加入測試，則應優先處理依賴問題，解依賴後立即加入測試。 ","date":"2023-12-17","objectID":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:1:0","series":["code-refactor"],"tags":["refactor"],"title":"程式碼重構 - 基本概念","uri":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#在重構之前"},{"categories":["software-development"],"content":" 2 基本的重構 - 整理程式碼 移除不必要的程式碼 未使用的成員 執行不到的程式碼 過多的程式註解 舊版寫法的保留方式其實可以靠版控，不需要全部留在程式碼內影響判讀 為何使用某種寫法的說明盡可能精簡，或者讓他變成方法或類別的說明，不建議在程式區段中間加入過多的說明資訊 可以靠著 IDE 的建議功能調整寫法，除了藉機學習各種新寫法之外，還可以挑一種在團隊間容易溝通的寫法來使用 若情況允許，建議安裝 JetBrains 出品的擴充套件或使用該廠商的 IDE，或使用其他類似功能的擴充 修正命名 修正錯字 修正命名以符合團隊規範或使用的開發語言習慣 更正方法名稱以用於釐清用途 處理魔術數字 將寫死的文字或數字改為變數或常數，以利於後續作業判斷 處理前 cs //這邊我們並不清楚 1 這個數字所代表的含意，必須額外查表 if (input == 1) { //do something } 處理後 cs //把 1 拉出來變成變數，並設定一個名稱，可以快速的理解判斷式的目的 var userUnit = 1; if (input == userUnit) { //do something } 尋找重複 -\u003e 移除重複 抽出行為方法 -\u003e 確認行為是否相同 -\u003e 整合重複的方法 Tips: 不見得所有的重複都必須處理，應該是要依據該區塊的行為去決定這個重複是否應被處理。有時候，適當的保留重複可以方便後續的調整。 確認邏輯並凸顯意圖 修正 Code Smell ","date":"2023-12-17","objectID":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/:2:0","series":["code-refactor"],"tags":["refactor"],"title":"程式碼重構 - 基本概念","uri":"/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/#基本的重構---整理程式碼"},{"categories":[],"content":"vim 操作筆記","date":"2023-11-29","objectID":"/2023/11/vim-memo/","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/"},{"categories":[],"content":"我在幾年前上過 91 的極速開發後，已經習慣在日常的文字編輯工具以及開發工具中啟用 vim 來進行文字編輯，這邊我將先前整理的一些資料整理出來以方便查閱。 詳細內容以及我自己使用的 vimrc 檔案後續會再安排公開，目前先讓我繼續鎖在私有git 裡面吧 此篇筆記為基礎 vim 命令，可搭配各 IDE 的 vim 套件來在 IDE 中開啟 vim 命令的支援。 ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:0:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#"},{"categories":[],"content":" 1 很重要若有需要可關注 91 的 FB 以取得最新資訊 91 極速開發 #202401-online version ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:1:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#很重要"},{"categories":[],"content":" 2 擺在前面的參考文件 Vim 指令中文說明 此網站內容完整，有許多在本文件沒有寫的額外命令 (主因是我比較少用)，若有興趣可參閱 成大資工wiki VIM-keyboard-shortcuts Vim help ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:2:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#擺在前面的參考文件"},{"categories":[],"content":" 3 各 IDE 套件 Visual Studio - VsVim Visual Studio Code - Vim JetBrains IDE Extensions - ideaVim Chrome - Vimium ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:3:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#各-ide-套件"},{"categories":[],"content":" 4 Vim 功能指令 指令 作用 備註 :source [vimrc file path] 重新讀取 vimrc 設定檔，檔案位置可用 ~/ 來代表使用者資料夾 :set rnu 設定左側行數顯示區以相對行數顯示 :wq 儲存並關閉目前檔案 在使用命令列進入 Linux 並操作 Vim 時會需要 :x 儲存並關閉目前檔案 在使用命令列進入 Linux 並操作 Vim 時會需要 :w 儲存目前檔案 在使用命令列進入 Linux 並操作 Vim 時會需要 :q! 關閉目前檔案 (不儲存) 在使用命令列進入 Linux 並操作 Vim 時會需要 :wqa 儲存並關閉所有檔案 :noh 移除使用 / 查詢後留下的標記 (Linux 上的 VIM 會發生此狀況) :only 關閉所有浮動視窗，僅保留編輯器區塊 (vscode 有效，rider 無效) :tabonly 關閉目前開啟分頁以外的其他分頁 ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:4:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#vim-功能指令"},{"categories":[],"content":" 5 模式代號 N = normal I = Insert V = Visual G = Global (N/I/V 皆作用) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:5:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#模式代號"},{"categories":[],"content":" 6 字詞定義 n mode = 標準模式 (Normal Mode) i mode = 輸入模式 (Insert Mode) v mode = 選擇模式 (Visual Mode) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:6:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#字詞定義"},{"categories":[],"content":" 7 Vim 基本按鍵命令對應英文輸入法的輸入方式，例如命令 i = 直接輸入 i，命令 I = Shift+i 模式 命令 作用 備註 常用項標記 N/V h 方向鍵 左 * N/V j 方向鍵 下 * N/V k 方向鍵 上 * N/V l 方向鍵 右 * N i 在目前游標位置的前方進入 i mode * N I 在目前游標位置的行首進入 i mode N a 在目前游標位置的後方進入 i mode * N A 在目前游標位置的行尾進入 i mode N v 選擇文字 (會進入 v mode) N V 選擇一行 (會進入 v mode) * V o 在選取字節的頭、尾切換 僅在選取單一字節時適用 V O 在選取字節的頭、尾切換 僅在選取單一字節時適用 N o 在下一行新增一行並進入 i mode * N O 在上一行新增一行並進入 i mode * N/V ~ 所選文字的字母大小寫轉換 N/V s 移除游標位置 (選取文字) 後進入 i mode * N S 清除游標所在行所有內容，並進入 i mode * N f 往後搜尋一個字母 N F 往前搜尋一個字母 N / 往後搜尋一組文字 * N ? 往前搜尋一組文字 * N J 將下一行與目前行合併 * N $ 將游標移動到行尾 N . 重複執行上一次 “進入 Insert Mode” 的指令 \u0026 在 Insert Mode 輸入的內容 若是選取文字後再用 s 這一類指令進入輸入模式，會連選取幾個文字這一件事情都重複執行 * N n 重複前一次的 /?fF 等搜尋命令 * N N 重複前一次的 /?fF 等搜尋命令 (反向執行) * N e 游標移動到單字結尾 * N E 游標移動到單字結尾後的一個標點符號 N w 游標移動到下一個單字的字首 * N W 游標移動到下一個字段的字首 (僅認換行符號或者空白) N b 游標移動到上一個單字的字首 * N B 游標移動到上一個字段的字首 (僅認換行符號或者空白) V d 刪除所選項目 (功能跟 v mode 下的 x 一樣，但是會等待使用者輸入組合命令，例如 d3l = 往右刪除 3 個字元，但是使用 x 命令時會直接執行命令) * N D 直接從目前游標位置刪除到行尾 N C 直接從目前游標位置刪除到行尾，並進入輸入模式 N x 剪下游標目前所在字元 N X 剪下游標目前所在的前一個字元 V x 剪下已選取字元 V X 剪下已選取字元的所在行整行 N p 在游標目前所在字元後方貼上(插入)用 y 指令複製的資料 不與系統剪貼簿共用複製資料 N P 在游標目前所在字元前方貼上(插入)用 y 指令複製的資料 不與系統剪貼簿共用複製資料 V p 用複製的內容覆蓋掉選取的內容 (與系統選取後貼上效果相同) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:7:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#vim-基本按鍵"},{"categories":[],"content":" 8 vim 組合命令","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#vim-組合命令"},{"categories":[],"content":" 8.1 Normal Mode 的組合命令起始鍵 組合 說明 v + 命令 進入 Visual Mode 然後執行命令 c + 命令 剪下符合命令範圍的文字，執行完畢後會進入 Insert Mode y + 命令 複製符合命令範圍的文字 (如果是跳躍游標的命令，則會從目前位置刪到游標到達的位置) d + 命令 刪除符合命令範圍的文字 (如果是跳躍游標的命令，則會從目前位置刪到游標到達的位置) gu + 命令 變更 命令移動軌跡 / 會被命令標記 中的英文字母都變更為小寫 gU + 命令 變更 命令移動軌跡 / 會被命令標記 中的英文字母都變更為大寫 命令可以是 選取命令 (下一節內容) 游標移動命令 (j, w, b, 3j, ]} ..etc) 行移動 (j,k) 的命令會以 行 為單位執行 剪下、複製、刪除都會把文字移動到 vim 的預設剪貼簿 ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:1","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#normal-mode-的組合命令起始鍵"},{"categories":[],"content":" 8.2 選取命令基本命令可在 Visual Mode 中直接作用，主要為 2 字元命令，組合為 [選取範圍][環繞符號] 8.2.1 選取範圍 字元 功能 i 不包含環繞符號 a 包含環繞符號 8.2.2 環繞符號 環繞符號 命令字 備註 小括號 () b,(,) 中括號 [] [,] 大括號 {} B,{,} xml 標籤 \u003cOOO\u003e\u003c/OOO\u003e t 雙引號 \"\" \" a\" 這組命令在已選取多個字元時會無作用 單引號 '' ' 空行 p (小寫) ip 會選擇兩個空白行之間的行，a 則是包含前方空白行 (後方空白行的部分應只包含段行符號) 任意符號 w (小寫) 選取任意符號間的文字，只要前後的字元都屬於符號即可 特定符號 W 此命令只認 空白、換行、)、]、}(、[、{ 這三個符號比較特別，需要前方為空白時才會被視為可作用的符號 8.2.3 常用的組合命令表 (VIM 原生) 模式 命令 作用 備註 N ciw 移除目前所在單字/字段後進入 i mode N cw 往後移除文字後進入 i mode (會停在 w 命令會到達的位置，大寫 W 亦同) N cb 往前移除文字後進入 i mode (會停在 b 命令會到達的位置，大寫 B 亦同) N diw 移除目前所在單字/字段 N dw 往後移除文字 (會停在 w 命令會到達的位置，大寫 W 亦同) N db 往後移除文字 (會停在 b 命令會到達的位置，大寫 B 亦同) N dd 刪除行 N cc 刪除行，並進入輸入模式 N viw 選擇一個單字 (但是我更喜歡 Ctrl + D 的選取快捷鍵) N vi( / vi) 選擇 () 內的單字，() 可替換為 {} / [] / \" 等 N va( / va) 選擇 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N di( / di) 刪除 () 內的單字，() 可替換為 {} / [] / \" 等 N da( / da) 刪除 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N zb 移動游標目前位置到螢幕最下方 N zt 移動游標目前位置到螢幕最上方 N ZZ 儲存並關閉目前檔案 N ZQ 關閉目前檔案 (不儲存) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:2","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#選取命令"},{"categories":[],"content":" 8.2 選取命令基本命令可在 Visual Mode 中直接作用，主要為 2 字元命令，組合為 [選取範圍][環繞符號] 8.2.1 選取範圍 字元 功能 i 不包含環繞符號 a 包含環繞符號 8.2.2 環繞符號 環繞符號 命令字 備註 小括號 () b,(,) 中括號 [] [,] 大括號 {} B,{,} xml 標籤 t 雙引號 \"\" \" a\" 這組命令在已選取多個字元時會無作用 單引號 '' ' 空行 p (小寫) ip 會選擇兩個空白行之間的行，a 則是包含前方空白行 (後方空白行的部分應只包含段行符號) 任意符號 w (小寫) 選取任意符號間的文字，只要前後的字元都屬於符號即可 特定符號 W 此命令只認 空白、換行、)、]、}(、[、{ 這三個符號比較特別，需要前方為空白時才會被視為可作用的符號 8.2.3 常用的組合命令表 (VIM 原生) 模式 命令 作用 備註 N ciw 移除目前所在單字/字段後進入 i mode N cw 往後移除文字後進入 i mode (會停在 w 命令會到達的位置，大寫 W 亦同) N cb 往前移除文字後進入 i mode (會停在 b 命令會到達的位置，大寫 B 亦同) N diw 移除目前所在單字/字段 N dw 往後移除文字 (會停在 w 命令會到達的位置，大寫 W 亦同) N db 往後移除文字 (會停在 b 命令會到達的位置，大寫 B 亦同) N dd 刪除行 N cc 刪除行，並進入輸入模式 N viw 選擇一個單字 (但是我更喜歡 Ctrl + D 的選取快捷鍵) N vi( / vi) 選擇 () 內的單字，() 可替換為 {} / [] / \" 等 N va( / va) 選擇 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N di( / di) 刪除 () 內的單字，() 可替換為 {} / [] / \" 等 N da( / da) 刪除 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N zb 移動游標目前位置到螢幕最下方 N zt 移動游標目前位置到螢幕最上方 N ZZ 儲存並關閉目前檔案 N ZQ 關閉目前檔案 (不儲存) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:2","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#選取範圍"},{"categories":[],"content":" 8.2 選取命令基本命令可在 Visual Mode 中直接作用，主要為 2 字元命令，組合為 [選取範圍][環繞符號] 8.2.1 選取範圍 字元 功能 i 不包含環繞符號 a 包含環繞符號 8.2.2 環繞符號 環繞符號 命令字 備註 小括號 () b,(,) 中括號 [] [,] 大括號 {} B,{,} xml 標籤 t 雙引號 \"\" \" a\" 這組命令在已選取多個字元時會無作用 單引號 '' ' 空行 p (小寫) ip 會選擇兩個空白行之間的行，a 則是包含前方空白行 (後方空白行的部分應只包含段行符號) 任意符號 w (小寫) 選取任意符號間的文字，只要前後的字元都屬於符號即可 特定符號 W 此命令只認 空白、換行、)、]、}(、[、{ 這三個符號比較特別，需要前方為空白時才會被視為可作用的符號 8.2.3 常用的組合命令表 (VIM 原生) 模式 命令 作用 備註 N ciw 移除目前所在單字/字段後進入 i mode N cw 往後移除文字後進入 i mode (會停在 w 命令會到達的位置，大寫 W 亦同) N cb 往前移除文字後進入 i mode (會停在 b 命令會到達的位置，大寫 B 亦同) N diw 移除目前所在單字/字段 N dw 往後移除文字 (會停在 w 命令會到達的位置，大寫 W 亦同) N db 往後移除文字 (會停在 b 命令會到達的位置，大寫 B 亦同) N dd 刪除行 N cc 刪除行，並進入輸入模式 N viw 選擇一個單字 (但是我更喜歡 Ctrl + D 的選取快捷鍵) N vi( / vi) 選擇 () 內的單字，() 可替換為 {} / [] / \" 等 N va( / va) 選擇 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N di( / di) 刪除 () 內的單字，() 可替換為 {} / [] / \" 等 N da( / da) 刪除 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N zb 移動游標目前位置到螢幕最下方 N zt 移動游標目前位置到螢幕最上方 N ZZ 儲存並關閉目前檔案 N ZQ 關閉目前檔案 (不儲存) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:2","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#環繞符號"},{"categories":[],"content":" 8.2 選取命令基本命令可在 Visual Mode 中直接作用，主要為 2 字元命令，組合為 [選取範圍][環繞符號] 8.2.1 選取範圍 字元 功能 i 不包含環繞符號 a 包含環繞符號 8.2.2 環繞符號 環繞符號 命令字 備註 小括號 () b,(,) 中括號 [] [,] 大括號 {} B,{,} xml 標籤 t 雙引號 \"\" \" a\" 這組命令在已選取多個字元時會無作用 單引號 '' ' 空行 p (小寫) ip 會選擇兩個空白行之間的行，a 則是包含前方空白行 (後方空白行的部分應只包含段行符號) 任意符號 w (小寫) 選取任意符號間的文字，只要前後的字元都屬於符號即可 特定符號 W 此命令只認 空白、換行、)、]、}(、[、{ 這三個符號比較特別，需要前方為空白時才會被視為可作用的符號 8.2.3 常用的組合命令表 (VIM 原生) 模式 命令 作用 備註 N ciw 移除目前所在單字/字段後進入 i mode N cw 往後移除文字後進入 i mode (會停在 w 命令會到達的位置，大寫 W 亦同) N cb 往前移除文字後進入 i mode (會停在 b 命令會到達的位置，大寫 B 亦同) N diw 移除目前所在單字/字段 N dw 往後移除文字 (會停在 w 命令會到達的位置，大寫 W 亦同) N db 往後移除文字 (會停在 b 命令會到達的位置，大寫 B 亦同) N dd 刪除行 N cc 刪除行，並進入輸入模式 N viw 選擇一個單字 (但是我更喜歡 Ctrl + D 的選取快捷鍵) N vi( / vi) 選擇 () 內的單字，() 可替換為 {} / [] / \" 等 N va( / va) 選擇 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N di( / di) 刪除 () 內的單字，() 可替換為 {} / [] / \" 等 N da( / da) 刪除 () 內包含()的單字，() 可替換為 {} / [] / \" 等 N zb 移動游標目前位置到螢幕最下方 N zt 移動游標目前位置到螢幕最上方 N ZZ 儲存並關閉目前檔案 N ZQ 關閉目前檔案 (不儲存) ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:8:2","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#常用的組合命令表-vim-原生"},{"categories":[],"content":" 自訂命令","date":"2023-11-29","objectID":"/2023/11/vim-memo/:0:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#自訂命令"},{"categories":[],"content":" 1 注意事項 在 Vimrc 檔案中，特定鍵位的代碼個別如下 Vim 命令 \u003cCR\u003e = 鍵盤的 \u003cEnter\u003e Vim 命令 \u003cA\u003e = 鍵盤的 \u003cAlt\u003e 此設定在 VSCode 中無效 Vim 命令 \u003cC\u003e = 鍵盤的 \u003cCtrl\u003e Vim 命令 \u003cBS\u003e = 鍵盤的 \u003cBackSpace\u003e ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:1:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#注意事項"},{"categories":[],"content":" 2 常見的自訂命令 模式 命令 作用 Vimrc 中設定的 Vim 行為 I jj 由 insert mode 轉回 normal mode \u003cEsc\u003e N hh 模擬 home 鍵功能 ^ N ll 模擬 end 鍵功能 $ ","date":"2023-11-29","objectID":"/2023/11/vim-memo/:2:0","series":[],"tags":["Memo"],"title":"vim memo","uri":"/2023/11/vim-memo/#常見的自訂命令"},{"categories":["Linux"],"content":"此邊筆記紀錄如何在 dockerfile 中設定 debian 11/12 與 alpine 中的 openSSL config 檔案 ","date":"2023-11-27","objectID":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/:0:0","series":[],"tags":["Memo"],"title":"Openssl Tls Version Downgrade in Dockerfile","uri":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/#"},{"categories":["Linux"],"content":" 1 debain 11 (openSSL 1.0.x) dockerfile RUN sed -i 's/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g' /etc/ssl/openssl.cnf RUN sed -i 's/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g' /etc/ssl/openssl.cnf RUN sed -i 's/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g' /usr/lib/ssl/openssl.cnf RUN sed -i 's/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g' /usr/lib/ssl/openssl.cnf #RUN sed -i 's/MinProtocol = TLSv1.2/MinProtocol = TLSv1/g; s/DEFAULT@SECLEVEL=2/DEFAULT@SECLEVEL=1/g' /usr/lib/ssl/openssl.cnf ","date":"2023-11-27","objectID":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/:1:0","series":[],"tags":["Memo"],"title":"Openssl Tls Version Downgrade in Dockerfile","uri":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/#debain-11-openssl-10x"},{"categories":["Linux"],"content":" 2 debain 12 (openSSL 3.0.x) dockerfile RUN sed -i 's/openssl_conf = openssl_init/#openssl_conf = openssl_init/' /etc/ssl/openssl.cnf RUN sed -i '1i openssl_conf = default_conf' /etc/ssl/openssl.cnf \u0026\u0026 echo \"\\n[ default_conf ]\\nssl_conf = ssl_sect\\n[ssl_sect]\\nsystem_default = system_default_sect\\n[system_default_sect]\\nMinProtocol = TLSv1\\nCipherString = DEFAULT:@SECLEVEL=1\" \u003e\u003e /etc/ssl/openssl.cnf ","date":"2023-11-27","objectID":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/:2:0","series":[],"tags":["Memo"],"title":"Openssl Tls Version Downgrade in Dockerfile","uri":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/#debain-12-openssl-30x"},{"categories":["Linux"],"content":" 3 alpine (OpenSSL 3.0.x) dockerfile RUN sed -i 's/openssl_conf = openssl_init/#openssl_conf = openssl_init/' /etc/ssl/openssl.cnf RUN sed -i '1i openssl_conf = default_conf' /etc/ssl/openssl.cnf \u0026\u0026 echo -e \"\\n[ default_conf ]\\nssl_conf = ssl_sect\\n[ssl_sect]\\nsystem_default = system_default_sect\\n[system_default_sect]\\nMinProtocol = TLSv1\\nCipherString = DEFAULT:@SECLEVEL=1\" \u003e\u003e /etc/ssl/openssl.cnf ","date":"2023-11-27","objectID":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/:3:0","series":[],"tags":["Memo"],"title":"Openssl Tls Version Downgrade in Dockerfile","uri":"/2023/11/openssl-tls-version-downgrade-in-dockerfile/#alpine-openssl-30x"},{"categories":["Linux"],"content":"如果網路環境中會被替換憑證，且暫時無法取得憑證時，可以利用本篇筆記所記錄的方式處理憑證","date":"2023-11-27","objectID":"/2023/11/%E5%9C%A8-linux-%E5%AE%89%E8%A3%9D-ssl-%E4%B8%AD%E9%96%93%E4%BA%BA%E6%86%91%E8%AD%89/","series":[],"tags":["Memo"],"title":"在 linux 安裝 ssl 中間人憑證","uri":"/2023/11/%E5%9C%A8-linux-%E5%AE%89%E8%A3%9D-ssl-%E4%B8%AD%E9%96%93%E4%BA%BA%E6%86%91%E8%AD%89/"},{"categories":["Linux"],"content":"如果網路環境會被替換憑證，且暫時無法取得憑證時，可以利用本篇筆記所記錄的方式處理憑證 參考資料 Get SSL Certificate bash openssl s_client -connect {domain}:443 -showcerts 找出輸出文字中的所有憑證區塊，並存到 /usr/local/share/ca-certificates/*.crt bash cat \u003c\u003cEOF | sudo tee /usr/local/share/ca-certificates/your-cert.crt -----BEGIN CERTIFICATE----- -----END CERTIFICATE----- EOF 執行憑證更新 bash sudo update-ca-certificates 重啟需要使用憑證的服務 (例如 docker) ","date":"2023-11-27","objectID":"/2023/11/%E5%9C%A8-linux-%E5%AE%89%E8%A3%9D-ssl-%E4%B8%AD%E9%96%93%E4%BA%BA%E6%86%91%E8%AD%89/:0:0","series":[],"tags":["Memo"],"title":"在 linux 安裝 ssl 中間人憑證","uri":"/2023/11/%E5%9C%A8-linux-%E5%AE%89%E8%A3%9D-ssl-%E4%B8%AD%E9%96%93%E4%BA%BA%E6%86%91%E8%AD%89/#"},{"categories":["Kubernetes"],"content":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","date":"2023-02-26","objectID":"/2023/02/use-k3d-to-create-k3s/","series":[],"tags":[],"title":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","uri":"/2023/02/use-k3d-to-create-k3s/"},{"categories":["Kubernetes"],"content":"本文紀錄在本機使用 k3d CLI 快速使用 k3s 建立 kubernetes 叢集的方法 ","date":"2023-02-26","objectID":"/2023/02/use-k3d-to-create-k3s/:0:0","series":[],"tags":[],"title":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","uri":"/2023/02/use-k3d-to-create-k3s/#"},{"categories":["Kubernetes"],"content":" k3d 資訊 k3d 是社群開發的 k3s in docker 的快速建立叢集的工具，方便在 docker 內使用 k3s 建立 kubernetes 叢集 由於是純社群開發的工具，且因為是跑在 docker 內部，我會建議用在 kubernetes 上的服務開發用途，而非正式服務部署 ","date":"2023-02-26","objectID":"/2023/02/use-k3d-to-create-k3s/:0:0","series":[],"tags":[],"title":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","uri":"/2023/02/use-k3d-to-create-k3s/#k3d"},{"categories":["Kubernetes"],"content":" 1 語法紀錄 資訊 前置作業：安裝 docker 使用 k3d 建立 k8s 叢集，只有開放 k8s api server port 的命令 警告 這邊的 cluster 建立命令資訊如下 叢集名稱 = service-lab api server (master node) 數量 = 1 agent server (worker node) 數量 = 6 以下命令有開本機的 8080 port 配對到 k3s 的 loadbalance (80 port)，有需要開其他 port 可以另外設定 因為我這邊使用的服務都有搭配 istio 做事，跟 k3d 內建的網路工具 traefik 有衝突，所以要關掉 bash k3d cluster create service-lab --servers 1 --agents 6 --port 8080:80@loadbalancer --api-port 6443 --k3s-arg '--disable=traefik@server:0' 如果沒有要關的話，命令如下 bash k3d cluster create service-lab --servers 1 --agents 6 --api-port 6443 --port 8080:80@loadbalancer bash # 建立完叢集才想到要暴露 k8s 服務的進入 port 的時候可以這樣加 k3d cluster edit service-lab --port-add 8080:80@loadbalancer # or when create cluster k3d cluster create service-lab --servers 1 --agents 6 --port 8080:80@loadbalancer --api-port 6443 --k3s-arg '--disable=traefik@server:0' 移除 Cluster bash= k3d cluster delete service-lab 停止 Cluster bash= k3d cluster stop service-lab 啟動 Cluster bash= k3d cluster start service-lab ","date":"2023-02-26","objectID":"/2023/02/use-k3d-to-create-k3s/:1:0","series":[],"tags":[],"title":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","uri":"/2023/02/use-k3d-to-create-k3s/#語法紀錄"},{"categories":["Kubernetes"],"content":" 2 參考資料 k3s官網 k3d 官網 在k3d上快速安装Istio，助你在本地灵活使用K8S！ K3d and Istio (Service Mesh - Governing the data plane) ","date":"2023-02-26","objectID":"/2023/02/use-k3d-to-create-k3s/:2:0","series":[],"tags":[],"title":"使用 k3d 快速建立本機 Kubernetes (k3s) 叢集以用於測試與開發","uri":"/2023/02/use-k3d-to-create-k3s/#參考資料"},{"categories":[],"content":"以下紀錄一些常用的 C# 語法、特性 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:0:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#"},{"categories":[],"content":" 1 var 會自動依據給予的資料型態，在編譯時直接定義為強型別 編譯後不會是 var，而是強型別 使用 var 宣告匿名型別時，比較運算子不會一起複寫，只會處裡 Equals csharp var x = new { Name = \"Bill\", Age = 15 }; var y = new { Name = \"Bill\", Age = 15 }; Console.WriteLine($\"x == y {x == y}\"); //false Console.WriteLine($\"x.Equals(y) {x.Equals(y)}\"); //true ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:1:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#var"},{"categories":[],"content":" 2 匿名型別 直接使用 new {} 的形式建立的暫時性型別 相同組件 (相同專案) 中的 new { Name = “”} 產生的匿名型別都會被編譯為同一個型別物件，反之，不同專案的 new {Name = “”} 會因為編譯後屬於不同組件 (DLL)，因此運行時會建立不同的型別物件 匿名型別成員為唯讀 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:2:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#匿名型別"},{"categories":[],"content":" 3 TupleClass 類似於匿名型別，可動態建立物件 是參考型別物件 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:3:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#tupleclass"},{"categories":[],"content":" 4 ValueTuple C# 7.0 加入的型別 .NET Core 2.0 .NET Framework 4.7 低於以上版本請從 nuget 安裝套件 為結構，是實質型別 可以有 1~8 個泛型成員 第 8 的成員必須為結構 使用完畢後會釋放使用的記憶體資源 資料成員是欄位 (Field) csharp // 顯式宣告使用 ValueTuple.Create methods ValueTuple\u003cint, string\u003e x1 = ValueTuple.Create\u003cint, string\u003e(8, \"ABC\"); // 隱式宣告使用 ValueTuple Constructor var x2 = (8, \"ABC\"); // 具名宣告欄位名稱 (1) var x3 = (length: 8, letters: \"ABC\"); // 具名宣告欄位名稱 (2) (int length, string letters) x4 = (8, \"ABC\"); // 具名宣告欄位名稱 (3) -- 會以指派運算子的左邊為主 (int length, string letters) x5 = (first: 8, second: \"ABC\"); // 直接指派給區域變數 (int length, string letters) = (8, \"ABC\"); var (l, s) = (8, \"ABC\"); ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:4:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#valuetuple"},{"categories":[],"content":" 5 變數存放 實質型別存放於 Stack 記憶體，存取通常較快 參考型別存放於 Heap 記憶體，存取通常較慢 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:5:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#變數存放"},{"categories":[],"content":" 6 Boxing and Unboxing 參考型別資料轉存至實質型別：Boxing 實質型別資料轉存至參考型別：Unboxing 永遠閃不掉的 Boxing : int.GetType() ArrayList 必定有此問題 問題成因：實質型別與參考型別的記憶體存放機制不同，因此會為了符合目標型別而有記憶體複製轉移等效能損耗 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:6:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#boxing-and-unboxing"},{"categories":[],"content":" 7 防禦性複製 只會發生在實質型別 資料會整包複製出來 建構式不會產生防禦性複製 要防止防禦性複製的話，需要使用唯讀結構，且所有成員都是唯讀 結構宣告非 readonly，但是使用時使用 readonly 變數承接，就會有防禦性複製 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:7:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#防禦性複製"},{"categories":[],"content":" 8 欄位 (Field) 物件內的全域變數 通常為私有成員 (若需要作為公開成員，通常會使用屬性) ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:8:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#欄位-field"},{"categories":[],"content":" 9 屬性 (Property) 特定變數(欄位)的公開 Get / Set 方法 通常為公開成員 編譯後會自動長出私有欄位與 Get / Set 方法 編譯前 csharp public string SampleString { Get; Set; } 編譯後 (僅示意，編譯完的實際 IL Code 並非如此) csharp private string _sampleString; //實際變數名稱由編譯器產出 public string GetSampleString() { return _sampleString; } public void SetSampleString(string value) { _sampleString = value; } ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:9:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#屬性-property"},{"categories":[],"content":" 10 Nullable\u003cT\u003e T 被限制為結構 (ref : microsoft learn - system.nullable) 讓不能為 null 的結構偽裝為參考型別，變成可 null int? 實際上是 Nullable\u003cint\u003e，與 int 不同 判斷是否有值時，建議使用比較運算子，這樣在 LinQ to sql 時，出來的語法會比較漂亮 Nullable\u003cT\u003e.Equals 僅有實作 Equals(Object)，並沒有實作 Equals(T)，無法避免 boxing 問題，因此在 Nullable\u003cT\u003e 變數上盡可能不要使用 Equals Nullable.GetUnderlyingType 用於確認該類型是不是 Nullable，在反射時會需要使用 Nullable boxing 後沒有 Nullable，會呈現 Nullable\u003cT\u003e 的 T csharp int? I; Nullable.GetUnderlyingType(i.GetType()); 結果會是 null，因為執行 GetType() 的時候會 boxing，而當下並沒有內容值，因此取得的是 null 如果要確實的拿到型別，給 GetUnderlyingType 的參數需要用 typeof(int?) 才能真的拿到 int ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:10:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#nullablet"},{"categories":[],"content":" 11 運算式主體 簡化方法的宣告 csharp public string Something() =\u003e \"\"; //等同以下寫法 public string Something() { return \"\"; } ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:11:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#運算式主體"},{"categories":[],"content":" 12 參數關鍵子：ref / out / in ref: call by references out: 資料會回設定至該位置的外部變數，有 ValueTuple Structure 時就不是特別需要使用此關鍵字來傳出多項資料了 in: 會進行防禦性複製，在方法內對該參數的調整不會反映到呼叫端 備註：不要過度倚賴 out / ref 來回傳資料，容易導致方法的職責不明確 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:12:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#參數關鍵子ref--out--in"},{"categories":[],"content":" 13 nameof() 取得成員名稱 編譯後會成為字串 可降低誤字問題 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:13:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#nameof"},{"categories":[],"content":" 14 捨棄資料 csharp _ = GetSomething(); //GetSomething 方法所回傳的資料不會被使用 var _ = GetSomething(); //GetSomething 方法所回傳的資料會被存放於 _ 這個變數中 ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:14:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#捨棄資料"},{"categories":[],"content":" 15 擴充方法 可以為特定型別加入功能 有撰寫限制，必須符合以下條件 位於靜態類別 方法必定為靜態 第一個方法參數必須加上 this 關鍵字 設計擴充方法實應注意職責單一的問題 擴充方法內應盡可能降低外部依賴 擴充方法應為單純的處理邏輯 擴充方法應為無狀態方法 (不紀錄資料) ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:15:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#擴充方法"},{"categories":[],"content":" 16 泛型的型別控制 csharp public class SampleInput\u003cT\u003e where T : ISampleClass { } ","date":"2023-02-26","objectID":"/2023/02/csharp-feature/:16:0","series":[],"tags":["dotnet"],"title":"C# Feature","uri":"/2023/02/csharp-feature/#泛型的型別控制"},{"categories":["software-design"],"content":"RESTful WebApi 設計概念","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/"},{"categories":["software-design"],"content":"本文為以下書籍的閱讀筆記，整理與紀錄一些我認為重要的部分 Web API 建構與設計 ","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:0:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#"},{"categories":["software-design"],"content":" Web Api 設計","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:0:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#web-api-設計"},{"categories":["software-design"],"content":" 1 RESTful Api 所遵循的設計規則 資源是 URL 的一部分，例如 /users 每一個資源通常有兩種路由，分別代表單數與複數資料 複數：GET http://{domain}/api/users 單數：GET http://{domain}/api/users/{userid} 使用資源名詞而非動詞 行為：取得使用者資料 建議： GET {domain}/api/users/{userid} 不建議： GET {domain}/api/getUserInfo/{userid} 利用 HTTP 方法表示功能行為 HTTP 方法 URL: /users URL: /users/{userid} Get 取得所有使用者資料 取得指定 user id 的資料 POST 建立一位使用者 (資料以 Request Body 傳遞) 不適用 PUT 批次更新使用者 (資料以 Request Body 傳遞、資料必須為完整的 User 資料) 指定更新 user id 的資料 PATCH 批次更新使用者 (資料以 Request Body 傳遞、資料為部分的 User 資料) 指定更新 user id 的資料 DELETE 刪除所有使用者 刪除指定使用者 伺服器回傳標準的 HTTP 狀態碼來表示處理結果 回應碼 執行結果 2xx 成功 3xx 資源不存在、已被移除 4xx 用戶端錯誤(缺少參數或太多請求) 5xx 伺服器錯誤 RESTful Api 回傳格式通常為 JSON 或 XML ","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:1:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#restful-api-所遵循的設計規則"},{"categories":["software-design"],"content":" 2 URL 資源關係URL 的路徑要可以表達每個資源的關係 text GET {domain}/users/{userid}/name 取得 某個使用者id 的名稱 GET {domain}/unit/{unitid}/name 取得 某個單位id 的名稱 ","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:2:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#url-資源關係"},{"categories":["software-design"],"content":" 3 非 CRUD 操作以 HTTP 行為表示與資料的互動關係，以後續的資源欄位表示要進行的行為 HTTP 方法 對應行為 POST 驗證、比較等無更新資料的行為 PUT URL 即代表行為 PATCH 依據 query string 或是 request body 內的資料決定行為結果 範例 預期行為 HTTP 方法 URL 備註 驗證使用者資料資料 POST {domain}/users/verify 驗證資訊會放置於 Http Request Body 調整使用者狀態為有效或無效 (範例1) PATCH {domain}/users/{userid}/status?invalid=true 使用 query string 設定狀態 調整使用者狀態為有效或無效 (範例2) PATCH {domain}/users/{userid}/status 使用 HttpBody 設定狀態: Body Context = {“invalid”=true} 設定使用者為無效使用者 PUT {domain}/users/{userid}/status/invalid 設定使用者為有效使用者 PUT {domain}/users/{userid}/status/valid ","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:3:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#非-crud-操作"},{"categories":["software-design"],"content":" 4 C# .Net Core 3.1 後的 Route 設定參考資料 ","date":"2022-12-17","objectID":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/:4:0","series":[],"tags":[],"title":"RESTful WebApi 設計概念","uri":"/2022/12/restful-webapi-%E8%A8%AD%E8%A8%88%E6%A6%82%E5%BF%B5/#c-net-core-31-後的-route-設定"},{"categories":["Kubernetes"],"content":"最新版 Kubernetes 環境準備 - ubuntu 20.04 LTS \u0026 containerd 版本","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/"},{"categories":["Kubernetes"],"content":"kubernetes 安裝筆記 資訊 K8s: v1.25.1 OS: ubuntu server 20.04 LTS cri: containerd 1.6.8 Update Time 2022/09/17 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#"},{"categories":["Kubernetes"],"content":" Ubuntu 根目錄磁區由於先前主要習慣是使用 CentOS7，在磁區格式上慣用的是 xfs 格式，所以我有特別調整根目錄磁區的格式化類型為 xfs，而非 ubuntu 預設的 ext4 我這邊另外收集了一些網路上針對 xfs / ext4 兩者的比較資訊，供需要的人參考評估 StackExchange 上的一個針對 ubuntu 選擇 ext4 作為預設格式的原因回應 ubuntu tw 上的一篇各格式比較表(2009 年的文章了) XFS-vs-EXT4 的一篇簡中資源 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#ubuntu-根目錄磁區"},{"categories":["Kubernetes"],"content":" 主機校時","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#主機校時"},{"categories":["Kubernetes"],"content":" 1 安裝所需套件 安裝檢查 資訊 核心的同步服務是 ntp，所以裝 ntp 其實就夠了 bash # dpkg -l 可以列出已安裝套件 #dpkg -l | grep ntpdate dpkg -l | grep ntp 安裝語法 bash #sudo apt-get install ntpdate sudo apt install ntp 資訊 在 ubuntu 中，用 apt / apt-get 安裝套件時會預設啟用 (至少我在撰寫本文時，都不用特別另外執行 systemctl enable 命令，安裝的服務就會自行啟動了) ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#安裝所需套件"},{"categories":["Kubernetes"],"content":" 2 啟用自動校正 編輯設定檔 bash sudo vi /etc/ntp.conf 把 server 區塊的設定調整一下，改成中華電信的校時服務 校時伺服器參考 這邊有另外一組可以嘗試 其他參考 conf # org linux time server # pool 0.ubuntu.pool.ntp.org iburst # pool 1.ubuntu.pool.ntp.org iburst # pool 2.ubuntu.pool.ntp.org iburst # pool 3.ubuntu.pool.ntp.org iburst # taiwan time server pool tock.stdtime.gov.tw iburst pool watch.stdtime.gov.tw iburst pool time.stdtime.gov.tw iburst pool clock.stdtime.gov.tw iburst pool tick.stdtime.gov.tw iburst # Use Ubuntu's ntp server as a fallback. # pool ntp.ubuntu.com 改完需要重啟 bash sudo vi /etc/ntp.conf 資訊 這邊可以自己評估要不要調整，因為在改設定檔前使用 ntpq -p 命令去查他使用了那些校時伺服器時，有看到使用台灣的位置，也許這個調整行為是多的？ 確認服務狀態 ntp 在安裝後預設就會被啟用，因此可以用以下網路工具確認是否已開始監聽 UDP Port 123 bash netstat -tlunp # 如果沒有安裝網路工具，可以用以下命令安裝 sudo apt install net-tools 其他參考命令 bash # 查看目前使用的校時伺服器狀態 sudo ntpq -p # 啟動 sudo /etc/init.d/ntp start # 重開 sudo /etc/init.d/ntp restart # 停止 sudo /etc/init.d/ntp stop ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#啟用自動校正"},{"categories":["Kubernetes"],"content":" 3 參考 參考 1 參考 2 參考 3 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#參考"},{"categories":["Kubernetes"],"content":" containerd這邊筆記一個中國的 bili bili 連結 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#containerd"},{"categories":["Kubernetes"],"content":" 1 核心套件安裝 安裝參考 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#核心套件安裝"},{"categories":["Kubernetes"],"content":" 1.1 使用 apt-get 套件管理工具安裝安裝參考 in docker doc 資訊 因為 containerd 的最新版也在 docker 的儲存庫中，所以直接使用 docker 的來源。 使用套件安裝會自動啟用並且一起安裝需要的套件 runc 。 更新 apt-get 的套件庫 安裝需要的額外套件 bash sudo apt-get update sudo apt-get install \\ ca-certificates \\ curl \\ gnupg \\ lsb-release 設定安裝套件需要的憑證資料 bash sudo mkdir -p /etc/apt/keyrings curl -fsSL https://download.docker.com/linux/ubuntu/gpg | sudo gpg --dearmor -o /etc/apt/keyrings/docker.gpg echo \\ \"deb [arch=$(dpkg --print-architecture) signed-by=/etc/apt/keyrings/docker.gpg] https://download.docker.com/linux/ubuntu \\ $(lsb_release -cs) stable\" | sudo tee /etc/apt/sources.list.d/docker.list \u003e /dev/null 安裝 containerd bash sudo apt-get update sudo apt-get install containerd.io 需要指定版本可使用以下方式安裝 列出可用的版本 bash sudo apt-cache madison containerd.io 安裝指定版本 bash sudo apt-get install containerd.io=\u003cVERSION_STRING\u003e ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:1","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#使用-apt-get-套件管理工具安裝"},{"categories":["Kubernetes"],"content":" 1.2 使用手動安裝 資訊 這邊手動安裝僅作為整理記錄，我並未使用該方法安裝。 手動安裝的好處是不用多設定、安裝一些額外的東西，使用哪種安裝方式就因人而異了。 下載並設定 containerd containerd 於 2022-09-16 時的最新版下載連結 https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz 下載並解壓縮 bash wget https://github.com/containerd/containerd/releases/download/v1.6.8/containerd-1.6.8-linux-amd64.tar.gz sudo tar Czxvf /usr/local containerd-1.6.8-linux-amd64.tar.gz 下載 systemd 使用的 service 執行檔 bash wget https://raw.githubusercontent.com/containerd/containerd/main/containerd.service sudo mv containerd.service /usr/lib/systemd/system/ 下載並設定 runc runc 於 2022-09-16 時的最新版下載連結 https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64 下載並安裝 bash wget https://github.com/opencontainers/runc/releases/download/v1.1.4/runc.amd64 sudo install -m 755 runc.amd64 /usr/local/sbin/runc ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:2","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#使用手動安裝"},{"categories":["Kubernetes"],"content":" 2 調整設定檔path: /etc/containerd/config.toml 因為使用 安裝 containerd 時的預設設定檔長這樣 toml disabled_plugins = [\"cri\"] 使用 containerd 內部的預設設定檔覆蓋後再去調整 SystemdCgroup=true bash # 如果使用手動安裝的話，會沒有這個設定檔與資料夾，需要先手動建立資料夾 sudo mkdir -p /etc/containerd/ # 輸出 containerd 的預設設定檔出來 containerd config default | tee /etc/containerd/config.toml # 編輯該設定檔 vi /etc/containerd/config.toml # 預設設定的的 SystemdCgroup 設定為 false，改成 true 就可以了 # 或者也可以直接用 sed 處理 sudo sed -i 's/SystemdCgroup \\= false/SystemdCgroup \\= true/g' /etc/containerd/config.toml 設定 systemdCgroup = true (官方文件參考) toml [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] SystemdCgroup = true ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#調整設定檔"},{"categories":["Kubernetes"],"content":" 3 建立 crictl 設定調整這個設定檔一開始不存在，需要自己建立並寫入以下內容 bash vi /etc/crictl.yaml yaml 內容如下 yaml runtime-endpoint: unix:///run/containerd/containerd.sock image-endpoint: unix:///run/containerd/containerd.sock timeout: 10 debug: false ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#建立-crictl-設定調整"},{"categories":["Kubernetes"],"content":" 4 啟動 containerd bash sudo systemctl daemon-reload # 由於使用 apt-get 套件安裝的話會預設啟動，所以這邊建議使用重啟的命令 sudo systemctl restart containerd sudo systemctl enable --now containerd ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:4:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#啟動-containerd"},{"categories":["Kubernetes"],"content":" Network Settingref: 官方文件 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#network-setting"},{"categories":["Kubernetes"],"content":" Disable Swap參考文件 暫時關閉 bash sudo swapoff -a 警告 此命令僅是暫時性關閉，server 重開後仍會啟用 swap，因此需要搭配下一節的設定來完全關閉 swap 永久關閉 swap 註解掉以下命令開啟的檔案中，含有 swap 字樣的行次 bash sudo vim /etc/fstab 用 vim 開啟 /etc/sysctl.conf 檔案，並加入 vm.swappiness=0 有時候沒有設定此行也可以正常運行，但如果可以的話，關掉也許比較好 新主機設定後此檔案應該會長這樣 conf # ...其他原本就存在的註解資料 vm.swappiness=0 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#disable-swap"},{"categories":["Kubernetes"],"content":" Kubernetes CLI \u0026 SELinux Setref: 官方文件 bash sudo apt-get update # 這邊跟前面用套件安裝 containerd 的部分差了 apt-transport-https 這個套件，如果是用套件安裝 containerd 的話，可以考慮調整這條安裝命令 sudo apt-get install -y apt-transport-https ca-certificates curl sudo curl -fsSLo /usr/share/keyrings/kubernetes-archive-keyring.gpg https://packages.cloud.google.com/apt/doc/apt-key.gpg echo \"deb [signed-by=/usr/share/keyrings/kubernetes-archive-keyring.gpg] https://apt.kubernetes.io/ kubernetes-xenial main\" | sudo tee /etc/apt/sources.list.d/kubernetes.list sudo apt-get update sudo apt-get install -y kubelet kubeadm kubectl #指定版本 #sudo apt-get install -y kubelet=1.24.6-00 kubeadm=1.24.6-00 kubect #降版與指定版本 #更改版本記得 apt-mark unhold kubelet kubeadm kubectl #sudo apt-get install -y --allow-downgrades kubelet=1.24.6-00 kubeadm=1.24.6-00 kubect # 避免 apt-get 隨便更新相關套件 sudo apt-mark hold kubelet kubeadm kubectl 安裝完畢後可看到安裝了已下套件 bash Setting up conntrack (1:1.4.5-2) ... Setting up kubectl (1.25.1-00) ... Setting up ebtables (2.0.11-3build1) ... Setting up socat (1.7.3.3-2) ... Setting up cri-tools (1.25.0-00) ... Setting up kubernetes-cni (1.1.1-00) ... Setting up kubelet (1.25.1-00) ... Created symlink /etc/systemd/system/multi-user.target.wants/kubelet.service → /lib/systemd/system/kubelet.service. Setting up kubeadm (1.25.1-00) ... Processing triggers for man-db (2.9.1-1) ... ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#kubernetes-cli--selinux-set"},{"categories":["Kubernetes"],"content":" kubernetes cluster init / join command (use kubeadm) 預先拉取需要的 Image bash sudo kubeadm config images pull 建立 kubernetes cluster bash sudo kubeadm init # 指定 control-plane-endpoint sudo kubeadm init --control-plane-endpoint=\u003ccontrol-plane-endpoint-domain\u003e \\ --upload-certs #sudo kubeadm init --control-plane-endpoint=k8s-ubuntu-containerd.mshome.net \\ # --upload-certs # 指定版本 # 由於指定版本會需要對應版本的 kubeadm / kubelet 等工具，記得安裝對應版本的工具 sudo kubeadm init --control-plane-endpoint=\u003ccontrol-plane-endpoint-domain\u003e \\ --upload-certs --kubernetes-version=v1.24.6 reset kubernetes cluster bash kubectl drain \u003cnode name\u003e --delete-emptydir-data --force --ignore-daemonsets #kubectl drain \u003cnode name\u003e --delete-emptydir-data --force --ignore-daemonsets sudo kubeadm reset # 清除資料 sudo rm -rf /etc/cni/net.d # 重設 ip table sudo iptables -F \u0026\u0026 iptables -t nat -F \u0026\u0026 iptables -t mangle -F \u0026\u0026 iptables -X join kubernetes cluster bash sudo kubeadm join \u003ccontrol-endpoint\u003e:6443 --token \u003ctoken\u003e \\ --discovery-token-ca-cert-hash sha256:\u003chash\u003e ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#kubernetes-cluster-init--join-command-use-kubeadm"},{"categories":["Kubernetes"],"content":" Other Setting","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#other-setting"},{"categories":["Kubernetes"],"content":" 1 Master node","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#master-node"},{"categories":["Kubernetes"],"content":" 1.1 kubeconfig 1.1.1 bash profileMaster Node 在 kubeadm join / init 結束之後，可以考慮將 kubeconfig 檔案設定在 bash_profile 裡面 bash export KUBECONFIG=/etc/kubernetes/admin.conf vi .bash_profile .bash_profile 的設定 config # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export KUBECONFIG=/etc/kubernetes/admin.conf 1.1.2 一般使用者 (非 root 帳號) bash mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:1","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#kubeconfig"},{"categories":["Kubernetes"],"content":" 1.1 kubeconfig 1.1.1 bash profileMaster Node 在 kubeadm join / init 結束之後，可以考慮將 kubeconfig 檔案設定在 bash_profile 裡面 bash export KUBECONFIG=/etc/kubernetes/admin.conf vi .bash_profile .bash_profile 的設定 config # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export KUBECONFIG=/etc/kubernetes/admin.conf 1.1.2 一般使用者 (非 root 帳號) bash mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:1","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#bash-profile"},{"categories":["Kubernetes"],"content":" 1.1 kubeconfig 1.1.1 bash profileMaster Node 在 kubeadm join / init 結束之後，可以考慮將 kubeconfig 檔案設定在 bash_profile 裡面 bash export KUBECONFIG=/etc/kubernetes/admin.conf vi .bash_profile .bash_profile 的設定 config # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export KUBECONFIG=/etc/kubernetes/admin.conf 1.1.2 一般使用者 (非 root 帳號) bash mkdir -p $HOME/.kube sudo cp -i /etc/kubernetes/admin.conf $HOME/.kube/config sudo chown $(id -u):$(id -g) $HOME/.kube/config ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:1","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#一般使用者-非-root-帳號"},{"categories":["Kubernetes"],"content":" 1.2 single node如果需要在 master 上部署服務的話，需要使用以下命令 bash #kubectl taint nodes --all node-role.kubernetes.io/control-plane- kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master- ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:1:2","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#single-node"},{"categories":["Kubernetes"],"content":" 2 Weave net CNI如果是正在建立叢集，就會需要另外安裝 CNI ( Container Network Interface )，這邊採用 Weave net CNI 直接安裝 weave net doc - install bash #kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" kubectl apply -f https://github.com/weaveworks/weave/releases/download/v2.8.1/weave-daemonset-k8s.yaml # 1.24.6 #kubectl apply -f https://cloud.weave.works/k8s/net?k8s-version=Q2xpZW50IFZlcnNpb246IHZlcnNpb24uSW5mb3tNYWpvcjoiMSIsIE1pbm9yOiIyNSIsIEdpdFZlcnNpb246InYxLjI1LjIiLCBHaXRDb21taXQ6IjU4MzU1NDRjYTU2OGI3NTdhOGVjYWU1YzE1M2YzMTdlNTczNjcwMGUiLCBHaXRUcmVlU3RhdGU6ImNsZWFuIiwgQnVpbGREYXRlOiIyMDIyLTA5LTIxVDE0OjMzOjQ5WiIsIEdvVmVyc2lvbjoiZ28xLjE5LjEiLCBDb21waWxlcjoiZ2MiLCBQbGF0Zm9ybToibGludXgvYW1kNjQifQpLdXN0b21pemUgVmVyc2lvbjogdjQuNS43ClNlcnZlciBWZXJzaW9uOiB2ZXJzaW9uLkluZm97TWFqb3I6IjEiLCBNaW5vcjoiMjQiLCBHaXRWZXJzaW9uOiJ2MS4yNC42IiwgR2l0Q29tbWl0OiJiMzliZjE0OGNkNjU0NTk5YTUyZTg2NzQ4NWMwMmM0ZjlkMjhiMzEyIiwgR2l0VHJlZVN0YXRlOiJjbGVhbiIsIEJ1aWxkRGF0ZToiMjAyMi0wOS0yMVQxMzoxMjowNFoiLCBHb1ZlcnNpb246ImdvMS4xOC42IiwgQ29tcGlsZXI6ImdjIiwgUGxhdGZvcm06ImxpbnV4L2FtZDY0In0K 如果要特別調整網段 資訊 由於發現官方的安裝語法於 2022-10-11 時發現有變動，以下命令待測試 bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" 清除安裝 資訊 由於發現官方的安裝語法於 2022-10-11 時發現有變動，以下命令待測試 bash kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#weave-net-cni"},{"categories":["Kubernetes"],"content":" 網段資料參考全預設 weave-net cni 的 kubernetes cluster 網段 Used For Subnet Genmask Start End Kubernetes Pod Subnet (Weave-cni) 10.32.0.0/12 255.240.0.0 10.32.0.1 10.47.255.254 Kubernetes Service Subnet 10.105.0.0/12 255.240.0.0 10.105.0.1 10.111.255.254 ","date":"2022-09-16","objectID":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - ubuntu \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-ubuntu-with-containerd/#網段資料參考"},{"categories":["Kubernetes"],"content":"最新版 Kubernetes 環境準備 - centos7 \u0026 containerd 版本","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/"},{"categories":["Kubernetes"],"content":"定期更新版 kubernetes 安裝筆記 資訊 K8s: v1.25.0 OS: CentOs 7 (kernel = 3.10.1) cri: containerd 1.6.8-3.1.el7 Update Time 2022/09/14 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#"},{"categories":["Kubernetes"],"content":" 主機校時","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#主機校時"},{"categories":["Kubernetes"],"content":" 1 安裝所需套件 bash sudo yum install ntp ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#安裝所需套件"},{"categories":["Kubernetes"],"content":" 2 啟用自動校正 編輯設定檔 bash sudo vi /etc/ntp.conf 把 server 區塊的設定調整一下，改成中華電信的校時服務 (會比使用 linux 的校時伺服器快一點，因為比較近) 校時伺服器參考 這邊有另外一組可以嘗試 其他參考 conf # org linux time server # server 0.centos.pool.ntp.org iburst # server 1.centos.pool.ntp.org iburst # server 2.centos.pool.ntp.org iburst # server 3.centos.pool.ntp.org iburst # taiwan time server server tock.stdtime.gov.tw server watch.stdtime.gov.tw server time.stdtime.gov.tw server clock.stdtime.gov.tw server tick.stdtime.gov.tw 將校時功能加入系統服務 bash sudo systemctl start ntpd sudo systemctl enable ntpd 確認啟用狀態 bash systemctl status ntpd ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#啟用自動校正"},{"categories":["Kubernetes"],"content":" 3 參考 參考 1 參考 2 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#參考"},{"categories":["Kubernetes"],"content":" containerd","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#containerd"},{"categories":["Kubernetes"],"content":" 1 核心套件安裝 更新 yum 並定義 docker 工具來源 資訊 因為 containerd 的最新版也在 docker 的儲存庫中，所以直接使用 docker 的來源 bash sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安裝 containerd bash sudo yum install containerd.io 需要指定版本可使用以下方式安裝 列出可用的版本 bash sudo yum list containerd.io --showduplicates | sort -r 安裝指定版本 bash sudo yum install containerd.io-\u003cVERSION_STRING\u003e ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#核心套件安裝"},{"categories":["Kubernetes"],"content":" 2 調整設定檔path: /etc/containerd/config.toml 使用 yum 安裝 containerd 時的預設設定檔長這樣 toml disabled_plugins = [\"cri\"] 使用 containerd 內部的預設設定檔覆蓋後再去調整 SystemdCgroup=true bash # 輸出 containerd 的預設設定檔出來 sudo containerd config default | tee /etc/containerd/config.toml # 編輯該設定檔 sudo vi /etc/containerd/config.toml # 預設設定的的 SystemdCgroup 設定為 false，改成 true 就可以了 # 或者也可以直接用 sed 處理 sudo sed -i 's/SystemdCgroup \\= false/SystemdCgroup \\= true/g' /etc/containerd/config.toml 設定 systemdCgroup = true (官方文件參考) toml [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] SystemdCgroup = true ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#調整設定檔"},{"categories":["Kubernetes"],"content":" 3 建立 crictl 設定調整這個設定檔一開始不存在，需要自己建立並寫入以下內容 bash sudo vi /etc/crictl.yaml yaml 內容如下 yaml runtime-endpoint: unix:///run/containerd/containerd.sock image-endpoint: unix:///run/containerd/containerd.sock timeout: 10 debug: false ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#建立-crictl-設定調整"},{"categories":["Kubernetes"],"content":" 4 其他輔助性質的工具安裝","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:4:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#其他輔助性質的工具安裝"},{"categories":["Kubernetes"],"content":" 4.1 containerd 的 CNI 資訊 這個不裝不會影響 kubernetes 運作，但是會造成 containerd 內部出現錯誤時，無法在沒有 kubernetes 的狀態下進行容器操作。 cni 在文章撰寫當下 (2022-09-19 最新版本為 1.1.1) cni github bash sudo mkdir -p /opt/cni/bin/ sudo wget https://github.com/containernetworking/plugins/releases/download/v1.1.1/cni-plugins-linux-amd64-v1.1.1.tgz sudo tar Cxzvf /opt/cni/bin cni-plugins-linux-amd64-v1.1.1.tgz ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:4:1","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#containerd-的-cni"},{"categories":["Kubernetes"],"content":" 4.2 nerdctlnerdctl Github 是輔助性質的命令列工具，建議安裝 撰文當下最新版本連結如下 https://github.com/containerd/nerdctl/releases/download/v0.23.0/nerdctl-0.23.0-linux-amd64.tar.gz bash wget https://github.com/containerd/nerdctl/releases/download/v0.23.0/nerdctl-0.23.0-linux-amd64.tar.gz sudo tar Cxzvf /usr/local/bin nerdctl-0.23.0-linux-amd64.tar.gz 資訊 nerdctl 的發布清單裡面有一個是 nerdctl-full-{version}-linux-amd64.tar.gz，這個包含了 containerd / runc / CNI 等必要倚賴，如果使用手動安裝的話，也許可以考慮用這包一次全裝。 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:4:2","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#nerdctl"},{"categories":["Kubernetes"],"content":" 5 啟動 containerd 警告 啟動 containerd 的段落會放在這邊是因為，前面的所有安裝變更都會需要重啟 containerd !! bash sudo systemctl daemon-reload # 套件安裝會預設啟用 sudo systemctl enable --now containerd # 如果已經有設定啟用 containerd 的話就要用這個 sudo systemctl restart containerd ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:5:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#啟動-containerd"},{"categories":["Kubernetes"],"content":" Network Settingref: 官方文件 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#network-setting"},{"categories":["Kubernetes"],"content":" Disable Swap參考文件 暫時關閉 ```bash sudo swapoff -a ``` 警告 此命令僅是暫時性關閉，server 重開後仍會啟用 swap，因此需要搭配下一節的設定來完全關閉 swap 永久關閉 swap 註解掉以下命令開啟的檔案中，含有 swap 字樣的行次 bash sudo vim /etc/fstab 用 vim 開啟 /etc/sysctl.conf 檔案，並加入 vm.swappiness=0 有時候沒有設定此行也可以正常運行，但如果可以的話，關掉也許比較好 新主機設定後此檔案應該會長這樣 conf # sysctl settings are defined through files in # /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/. # # Vendors settings live in /usr/lib/sysctl.d/. # To override a whole file, create a new file with the same in # /etc/sysctl.d/ and put new settings there. To override # only specific settings, add a file with a lexically later # name in /etc/sysctl.d/ and put new settings there. # # For more information, see sysctl.conf(5) and sysctl.d(5). vm.swappiness=0 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#disable-swap"},{"categories":["Kubernetes"],"content":" Kubernetes CLI \u0026 SELinux Setref: 官方文件 bash cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF # Set SELinux in permissive mode (effectively disabling it) sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet 資訊 先前舊的命令會有 repo_gpgcheck 的問題，在撰文當下 (2022/09/12) 已被修正 若仍有相關問題的話，請參考官方說明 text If the baseurl fails because your Red Hat-based distribution cannot interpret basearch, replace \\$basearch with your computer's architecture. Type uname -m to see that value. For example, the baseurl URL for x86_64 could be: https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64. 安裝完畢後可看到安裝了已下套件 bash Installed: kubeadm.x86_64 0:1.25.0-0 kubectl.x86_64 0:1.25.0-0 kubelet.x86_64 0:1.25.0-0 Dependency Installed: conntrack-tools.x86_64 0:1.4.4-7.el7 cri-tools.x86_64 0:1.24.2-0 kubernetes-cni.x86_64 0:0.8.7-0 libnetfilter_cthelper.x86_64 0:1.0.0-11.el7 libnetfilter_cttimeout.x86_64 0:1.0.0-7.el7 libnetfilter_queue.x86_64 0:1.0.2-2.el7_2 socat.x86_64 0:1.7.3.2-2.el7 Complete! ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#kubernetes-cli--selinux-set"},{"categories":["Kubernetes"],"content":" kubernetes cluster init / join command (use kubeadm) 預先拉取需要的 Image bash kubeadm config images pull 建立 kubernetes cluster bash kubeadm init # 指定 control-plane-endpoint kubeadm init --control-plane-endpoint=\u003ccontrol-plane-endpoint-domain\u003e \\ --upload-certs reset kubernetes cluster bash kubeadm reset # 清除資料 rm -rf /etc/cni/net.d # 重設 ip table iptables -F \u0026\u0026 iptables -t nat -F \u0026\u0026 iptables -t mangle -F \u0026\u0026 iptables -X join kubernetes cluster bash kubeadm join \u003ccontrol-endpoint\u003e:6443 --token \u003ctoken\u003e \\ --discovery-token-ca-cert-hash sha256:\u003chash\u003e ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#kubernetes-cluster-init--join-command-use-kubeadm"},{"categories":["Kubernetes"],"content":" Other Setting","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#other-setting"},{"categories":["Kubernetes"],"content":" 1 Master nodeMaster Node 在 kubeadm join / init 結束之後，可以考慮將 kubeconfig 檔案設定在 bash_profile 裡面 bash export KUBECONFIG=/etc/kubernetes/admin.conf vi .bash_profile .bash_profile 的設定 config # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export KUBECONFIG=/etc/kubernetes/admin.conf ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#master-node"},{"categories":["Kubernetes"],"content":" 2 Weave net CNI如果是正在建立叢集，就會需要另外安裝 CNI ( Container Network Interface )，這邊採用 Weave net CNI 直接安裝 weave net doc - install bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 如果要特別調整網段 bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" 清除安裝 bash kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#weave-net-cni"},{"categories":["Kubernetes"],"content":" 網段資料參考全預設 weave-net cni 的 kubernetes cluster 網段 Used For Subnet Genmask Start End Kubernetes Pod Subnet (Weave-cni) 10.32.0.0/12 255.240.0.0 10.32.0.1 10.47.255.254 Kubernetes Service Subnet 10.105.0.0/12 255.240.0.0 10.105.0.1 10.111.255.254 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 containerd","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-containerd/#網段資料參考"},{"categories":["Kubernetes"],"content":"最新版 Kubernetes 環境準備 - centos7 \u0026 docker 版本","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/"},{"categories":["Kubernetes"],"content":"定期更新版 kubernetes 安裝筆記 資訊 K8s: v1.25.0 OS: CentOs 7 (kernel = 3.10.1) cri: docker 20.10.18 Update Time 2022/09/12 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#"},{"categories":["Kubernetes"],"content":" 主機校時","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#主機校時"},{"categories":["Kubernetes"],"content":" 1 安裝所需套件 bash sudo yum install ntp ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#安裝所需套件"},{"categories":["Kubernetes"],"content":" 2 啟用自動校正 編輯設定檔 bash sudo vi /etc/ntp.conf 把 server 區塊的設定調整一下，改成中華電信的校時服務 (會比使用 linux 的校時伺服器快一點，因為比較近) 校時伺服器參考 這邊有另外一組可以嘗試 其他參考 conf # org linux time server # server 0.centos.pool.ntp.org iburst # server 1.centos.pool.ntp.org iburst # server 2.centos.pool.ntp.org iburst # server 3.centos.pool.ntp.org iburst # taiwan time server server tock.stdtime.gov.tw server watch.stdtime.gov.tw server time.stdtime.gov.tw server clock.stdtime.gov.tw server tick.stdtime.gov.tw 將校時功能加入系統服務 bash sudo systemctl start ntpd sudo systemctl enable ntpd 確認啟用狀態 bash systemctl status ntpd ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#啟用自動校正"},{"categories":["Kubernetes"],"content":" 3 參考 參考 1 參考 2 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#參考"},{"categories":["Kubernetes"],"content":" Docker","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#docker"},{"categories":["Kubernetes"],"content":" 1 安裝之前 警告 在 kubernetes 1.24 版之後，由於被拔除了 docker 支援，所以請評估是否還有使用 docker 的需要，且就算是 docker，背後也是使用 containerd 來運行，所以如果不是要做為映像檔建置主機的話，其實可以考慮直接使用 containerd。 官方文件 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#安裝之前"},{"categories":["Kubernetes"],"content":" 2 核心套件安裝 更新 yum 並定義 docker 工具來源 bash sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安裝 docker-ce 與依賴套件 bash sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 資訊 由於是要做為 kuberntes 的容器執行核心，其實可以考慮不安裝 docker-compose-plugin 需要指定版本可使用以下方式安裝 列出可用的版本 bash sudo yum list docker-ce --showduplicates | sort -r 安裝指定版本 bash sudo yum install docker-ce-\u003cVERSION_STRING\u003e docker-ce-cli-\u003cVERSION_STRING\u003e containerd.io ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#核心套件安裝"},{"categories":["Kubernetes"],"content":" 3 調整設定檔建立與編輯 /etc/docker/daemon.json 官方對 Cgroup drivers 的說明 bash sudo mkdir /etc/docker cat \u003c\u003cEOF | sudo tee /etc/docker/daemon.json { \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" } } EOF ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#調整設定檔"},{"categories":["Kubernetes"],"content":" 4 啟動 docker bash sudo systemctl daemon-reload sudo systemctl enable docker sudo systemctl start docker ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:4:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#啟動-docker"},{"categories":["Kubernetes"],"content":" Cri-dockerd","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#cri-dockerd"},{"categories":["Kubernetes"],"content":" 1 Reference migrate-kubernetes-to-dockershim how-to-install-cri-dockerd-and-migrate-nodes-from-dockershim ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#reference"},{"categories":["Kubernetes"],"content":" 2 Install and configure 資訊 前述的參考中，使用的下載命令都是 wget ，不過我的環境沒有 wget 可以用，也不想多安裝東西，就改用最小安裝的 centos 就有的 curl 了 bash # 先到 OS 預設的暫存資料夾 cd /tmp # 確定目前 cri-dockerd 的版本並設定到環境參數中 echo $(curl -s https://api.github.com/repos/Mirantis/cri-dockerd/releases/latest|grep tag_name | cut -d '\"' -f 4) # 2022-09-11 時的最新版本 = 0.2.5 # 2022-09-11 時的最新版本網址 # https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.5/cri-dockerd-0.2.5.amd64.tgz curl -L -o cri-dockerd-0.2.5.amd64.tgz https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.5/cri-dockerd-0.2.5.amd64.tgz tar xvf cri-dockerd-0.2.5.amd64.tgz # Centos 可以考慮 rpm 安裝 # 安裝命令請自行測試 # centos 7 # curl -L -o cri-dockerd-0.2.5-3.el7.x86_64.rpm https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.5/cri-dockerd-0.2.5-3.el7.x86_64.rpm # centos 8 # curl -L -o cri-dockerd-0.2.5-3.el8.x86_64.rpm https://github.com/Mirantis/cri-dockerd/releases/download/v0.2.5/cri-dockerd-0.2.5-3.el8.x86_64.rpm # 移動執行檔案 sudo mv cri-dockerd/cri-dockerd /usr/local/bin/cri-dockerd # 清掉解壓縮時多出來的資料夾 sudo rm -rf cri-dockerd # 確認有沒有安裝成功 cri-dockerd --version cri-dockerd 0.2.0 (HEAD) curl -L -o cri-docker.service https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.service curl -L -o cri-docker.socket https://raw.githubusercontent.com/Mirantis/cri-dockerd/master/packaging/systemd/cri-docker.socket sudo mv cri-docker.socket cri-docker.service /etc/systemd/system/ sudo sed -i -e 's,/usr/bin/cri-dockerd,/usr/local/bin/cri-dockerd,' /etc/systemd/system/cri-docker.service ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#install-and-configure"},{"categories":["Kubernetes"],"content":" 3 enable Cri-docker.service / socket bash sudo systemctl daemon-reload sudo systemctl enable cri-docker.service sudo systemctl enable --now cri-docker.socket ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:3:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#enable-cri-dockerservice--socket"},{"categories":["Kubernetes"],"content":" Network Settingref: 官方文件 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#network-setting"},{"categories":["Kubernetes"],"content":" Disable Swap參考文件 暫時關閉 ```bash sudo swapoff -a ``` 警告 此命令僅是暫時性關閉，server 重開後仍會啟用 swap，因此需要搭配下一節的設定來完全關閉 swap 永久關閉 swap 註解掉以下命令開啟的檔案中，含有 swap 字樣的行次 bash sudo vim /etc/fstab 用 vim 開啟 /etc/sysctl.conf 檔案，並加入 vm.swappiness=0 有時候沒有設定此行也可以正常運行，但如果可以的話，關掉也許比較好 新主機設定後此檔案應該會長這樣 conf # sysctl settings are defined through files in # /usr/lib/sysctl.d/, /run/sysctl.d/, and /etc/sysctl.d/. # # Vendors settings live in /usr/lib/sysctl.d/. # To override a whole file, create a new file with the same in # /etc/sysctl.d/ and put new settings there. To override # only specific settings, add a file with a lexically later # name in /etc/sysctl.d/ and put new settings there. # # For more information, see sysctl.conf(5) and sysctl.d(5). vm.swappiness=0 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#disable-swap"},{"categories":["Kubernetes"],"content":" Kubernetes CLI \u0026 SELinux Setref: 官方文件 bash cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF # Set SELinux in permissive mode (effectively disabling it) sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet 資訊 先前舊的命令會有 repo_gpgcheck 的問題，在撰文當下 (2022/09/12) 已被修正 若仍有相關問題的話，請參考官方說明 text If the baseurl fails because your Red Hat-based distribution cannot interpret basearch, replace \\$basearch with your computer's architecture. Type uname -m to see that value. For example, the baseurl URL for x86_64 could be: https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64. 安裝完畢後可看到安裝了已下套件 bash Installed: kubeadm.x86_64 0:1.25.0-0 kubectl.x86_64 0:1.25.0-0 kubelet.x86_64 0:1.25.0-0 Dependency Installed: conntrack-tools.x86_64 0:1.4.4-7.el7 cri-tools.x86_64 0:1.24.2-0 kubernetes-cni.x86_64 0:0.8.7-0 libnetfilter_cthelper.x86_64 0:1.0.0-11.el7 libnetfilter_cttimeout.x86_64 0:1.0.0-7.el7 libnetfilter_queue.x86_64 0:1.0.2-2.el7_2 socat.x86_64 0:1.7.3.2-2.el7 Complete! ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#kubernetes-cli--selinux-set"},{"categories":["Kubernetes"],"content":" kubernetes cluster init / join command (use kubeadm) 資訊 我在公司環境的主機上並未設定 cri-socket 的參數，不確定是不是因為公司環境的 docker 版本是卡在 18.6.1 的關係 因為安裝 docker 的時候同時會裝 containerd，所以 kubeadm 會因為主機內有兩個容器執行服務而無法啟動，這時可以使用 --cri-socket 參數來指定要使用哪一個容器服務，也可以直接設定 kubeadm 的環境檔案來調整。 跟 kubeadm 相關的命令都需要加入此參數才能作用 預先拉取需要的 Image bash kubeadm config images pull --cri-socket unix:///var/run/cri-dockerd.sock 建立 kubernetes cluster bash kubeadm init --cri-socket unix:///var/run/cri-dockerd.sock # 指定 control-plane-endpoint kubeadm init --control-plane-endpoint=\u003ccontrol-plane-endpoint-domain\u003e \\ --upload-certs \\ --cri-socket unix:///var/run/cri-dockerd.sock reset kubernetes cluster bash kubeadm reset --cri-socket unix:///var/run/cri-dockerd.sock # 清除資料 rm -rf /etc/cni/net.d # 重設 ip table iptables -F \u0026\u0026 iptables -t nat -F \u0026\u0026 iptables -t mangle -F \u0026\u0026 iptables -X join kubernetes cluster bash kubeadm join \u003ccontrol-endpoint\u003e:6443 --token \u003ctoken\u003e \\ --discovery-token-ca-cert-hash sha256:\u003chash\u003e \\ --cri-socket unix:///var/run/cri-dockerd.sock ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#kubernetes-cluster-init--join-command-use-kubeadm"},{"categories":["Kubernetes"],"content":" Other Setting","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#other-setting"},{"categories":["Kubernetes"],"content":" 1 Master nodeMaster Node 在 kubeadm join / init 結束之後，可以考慮將 kubeconfig 檔案設定在 bash_profile 裡面 bash export KUBECONFIG=/etc/kubernetes/admin.conf vi .bash_profile .bash_profile 的設定 config # .bash_profile # Get the aliases and functions if [ -f ~/.bashrc ]; then . ~/.bashrc fi # User specific environment and startup programs PATH=$PATH:$HOME/bin export PATH export KUBECONFIG=/etc/kubernetes/admin.conf ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:1:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#master-node"},{"categories":["Kubernetes"],"content":" 2 Weave net CNI如果是正在建立叢集，就會需要另外安裝 CNI ( Container Network Interface )，這邊採用 Weave net CNI 直接安裝 weave net doc - install bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 如果要特別調整網段 bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" 清除安裝 bash kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:2:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#weave-net-cni"},{"categories":["Kubernetes"],"content":" 網段資料參考全預設 docker + weave-net cni 的 kubernetes cluster 網段 Used For Subnet Genmask Start End Kubernetes Pod Subnet (Weave-cni) 10.32.0.0/12 255.240.0.0 10.32.0.1 10.47.255.254 Kubernetes Service Subnet 10.105.0.0/12 255.240.0.0 10.105.0.1 10.111.255.254 Docker (default bridge) 172.17.0.0/16 255.255.0.0 172.17.0.1 172.17.255.254 Docker (custom bridge) 172.18.0.0/16 255.255.0.0 172.18.0.1 172.18.255.254 資訊 在 docker 中另外建立的 bridge 網段預設是第二段依序 +1，極限數值範圍為 172.16.0.1 - 172.31.255.254 即 subnet pool = 172.17.0.0/12 subnet size = 16 數值來源參考 ","date":"2022-09-13","objectID":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/:0:0","series":["kubernetes-install-memo"],"tags":["Install"],"title":"Kubernetes 環境準備 - centos7 \u0026 docker","uri":"/2022/09/kubernetes-node-prepare-for-centos7-with-docker/#網段資料參考"},{"categories":["Kubernetes","Installation"],"content":"Kubernetes 1.24 版本環境設定重點","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/"},{"categories":["Kubernetes","Installation"],"content":"由於 kubernetes 在 1.24 版之後已不預設支援 Docker ( kubernetes 1.24 release page )，所以照原本的安裝方式的話，在建立叢集時會出現錯誤。 但是因為原本的作法在安裝 Docker 時已經有安裝其他 kubernetes 有支援的容器套件 containerd，所以這篇主要紀錄如何去設定 containerd 來作為 Docker 的替代品，並紀錄一些跟原先的安裝參數不一樣的地方。 相關內容已更新至 Kubernetes 安裝筆記 part.1 : 環境準備~ 資訊 OS: CentOs 7 (kernel = 3.10.1) K8s: v1.24.1 (新安裝時預設使用當下的最新版，因此此版本資訊參考用) ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:0:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#"},{"categories":["Kubernetes","Installation"],"content":" 1 iptable 橋接設定變化來到 1.24 之後，第一個不一樣的環境設定舊識 iptable 的設定參數，原本舊版是 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf br_netfilter EOF cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-ip6tables = 1 net.bridge.bridge-nf-call-iptables = 1 EOF sudo sysctl --system 現在新版要改成這樣 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:1:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#iptable-橋接設定變化"},{"categories":["Kubernetes","Installation"],"content":" 2 containerd在原本的環境準備方式中，可以發現安裝 docker 的時候其實有另外裝一個叫做 containerd.io 的東西，其實這是核心的容器執行元件，詳細技術細節我這邊就不說了，小弟我才疏學淺，直接看技術文件一定比我這篇筆記來的詳細。 而 1.24 版本的 kubernetes 雖然拔掉了 docker 原生支援，但是其實 kubernetes 也可以直接使用 containerd 來操作容器的 (原本的操安裝方式比較像是藉由 docker 去操作 containerd)。所以，我們現在在已經有安裝相關套件的狀況下，只要找到方式讓 kubernetes 改用 containerd 來運作就行了~ 所以，接下來我們就是要開始設定 containerd 的相關參數 (可參考官方文件) ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:2:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#containerd"},{"categories":["Kubernetes","Installation"],"content":" 2.1 變更 configpath: /etc/containerd/config.toml 因為使用 yum 安裝 containerd 時的預設設定檔長這樣 (已忽略註解項目) toml disabled_plugins = [\"cri\"] 我們需要把 disabled_plugins 裡面的 cri 移除，並加入 systemd 的相關控制，所以設定檔會變成這樣 toml disabled_plugins = [] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] SystemdCgroup = true 警告 這個設定檔建議使用以下命令用 containerd 內部的預設設定檔覆蓋後再去調整 SystemdCgroup=true 因為我一開始使用上面的設定的時候有發生 CoreDNS 起不來的問題，之後就好了，也許可以評估一下要不要換用預設設定檔去改。 bash # 輸出 containerd 的預設設定檔出來 containerd config default | tee /etc/containerd/config.toml # 編輯該設定檔 vi /etc/containerd/config.toml # 預設設定的的 SystemdCgroup 設定為 false，改成 true 就可以了 然後啟動 (重啟) containerd bash sudo systemctl daemon-reload sudo systemctl enable --now containerd # 如果已經有設定啟用 containerd 的話就要用這個 sudo systemctl restart containerd ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:2:1","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#變更-config"},{"categories":["Kubernetes","Installation"],"content":" 2.2 crictl 設定調整這個設定檔一開始不存在，需要自己建立並寫入以下內容 bash vi /etc/crictl.yaml yaml 內容如下 yaml runtime-endpoint: unix:///run/containerd/containerd.sock image-endpoint: unix:///run/containerd/containerd.sock timeout: 10 debug: false ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:2:2","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#crictl-設定調整"},{"categories":["Kubernetes","Installation"],"content":" 3 Single Node SettingKubernetes 1.24 之後的 single node 設定也有調整 舊的命令只要這樣下就可以了 bash kubectl taint nodes --all node-role.kubernetes.io/master- 新的要這樣下 bash # kubernetes 1.24 要改用這個 kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master- ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:3:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#single-node-setting"},{"categories":["Kubernetes","Installation"],"content":" 4 待測試、解決問題 同時執行 docker \u0026 containerd (如果還想要使用 docker 的話，我不確定是否可以並行，理論上是可以，因為 docker 也是使用 containerd 來處理容器的) ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:4:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#待測試解決問題"},{"categories":["Kubernetes","Installation"],"content":" 5 參考資料 完整的 kubernetes 1.24 安裝方式 - 中文 此網頁 我有參考這邊來確認自己的安裝方式有缺什麼東西 另外一篇安裝 kubernetes 1.24 \u0026 使用 CentOs 的 Blog 別人整理的 kubeadm 1.24 版使用 docker 的安裝方式在 此網頁 有些設定跟我不一樣，而且這篇使用的 OS 是 CentOs 8，我是用 7 另外，由於我改使用 containerd 來做為 kubernetes 的容器執行工具，所以這篇使用 docker 的作法也僅作為參考 ","date":"2022-06-11","objectID":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/:5:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 1.24 版本環境設定重點","uri":"/2022/06/kubernetes-1.24-%E7%89%88%E6%9C%AC%E7%92%B0%E5%A2%83%E8%A8%AD%E5%AE%9A%E9%87%8D%E9%BB%9E/#參考資料"},{"categories":["ArgoCD"],"content":"ArgoCD install use kustomizaion","date":"2022-05-31","objectID":"/2022/05/argocd-install/","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/"},{"categories":["ArgoCD"],"content":"使用 kustomization 安裝 ArgoCD，並且利用 patch 來加入 istio 所需要的 Label。 此篇文所使用的安裝設定檔連結：Github ","date":"2022-05-31","objectID":"/2022/05/argocd-install/:0:0","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/#"},{"categories":["ArgoCD"],"content":" ArgoCD Memo設定檔中也包含了 --insecure 執行參數，以便使用 http 連線 此定義檔主要增加 Kubernetes 的 Label 設定 (app, version)，讓 Istio 可正常存取 為了方便以後的更新，有特別將各種不同類型的 patch 設定檔切割出來 安裝檔案說明 檔案 說明 Kustomiztion.yaml kustomiztion 定義檔 install-2.3.4.yaml argocd 官方 2.3.4 版本安裝檔 VirtualService.yaml Istio 所需的 VirtualService 服務安裝檔 Gateway.yaml Istio 所需的 Gateway 服務安裝檔 (不是 IngressGateway) istio_patches_deployment.yaml argocd 官方版本安裝檔的覆蓋參數，增加 Istio 所需的 Label 定義 istio_patches_service.yaml argocd 官方版本安裝檔的覆蓋參數，增加 Istio 所需的 Label 定義 istio_patches_statefulset.yaml argocd 官方版本安裝檔的覆蓋參數，增加 Istio 所需的 Label 定義 ","date":"2022-05-31","objectID":"/2022/05/argocd-install/:0:0","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/#argocd-memo"},{"categories":["ArgoCD"],"content":" 0.1 安裝檔準備 download install yaml (option) 指定版本 bash= curl -sSL https://raw.githubusercontent.com/argoproj/argo-cd/v2.3.4/manifests/install.yaml -o install-2.3.4.yaml 最新版本 bash= curl -sSL https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml -o install-latest.yaml 建立 namespace 純建立 bash= kubectl create namespace argocd 含設定 istio 掛車 bash= kubectl create namespace argocd kubectl label namespace argocd istio-injection=enabled --overwrite # 如果安裝 istio 的時候是特別設定版本的話 (通常出現在有使用金絲雀部署來更新 istio 的狀況) # 如果已經有設定掛車的話，可以用這方式刪掉舊的同時設定新的 #kubectl label namespace argocd istio-injection- istio.io/rev=1-13-3 kubectl label namespace argocd istio.io/rev=1-13-3 ","date":"2022-05-31","objectID":"/2022/05/argocd-install/:0:1","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/#安裝檔準備"},{"categories":["ArgoCD"],"content":" 0.2 When Upgrade 升級後不會更新設定檔，因此原始的密碼與設定都相同 可以先用以下命令檢查差異 (cmd 位置要先到 argocd kustomiztion 的位置) bash= # 查看差異 kubectl diff -k ./ # 將差異資料輸出到特定檔案 kubectl diff -k ./ \u003e different-data.txt # 測試執行並輸出結果 kubectl apply -k ./ --dry-run=client \u003e dry-run.txt ","date":"2022-05-31","objectID":"/2022/05/argocd-install/:0:2","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/#when-upgrade"},{"categories":["ArgoCD"],"content":" 0.3 Install text kubectl apply -k ./ ","date":"2022-05-31","objectID":"/2022/05/argocd-install/:0:3","series":null,"tags":["Install"],"title":"ArgoCD install use kustomizaion","uri":"/2022/05/argocd-install/#install"},{"categories":["Istio"],"content":"Istio 設定 http request header 來讓內部容器使用 https","date":"2022-04-12","objectID":"/2022/04/istio-%E8%A8%AD%E5%AE%9A-http-request-header-%E4%BE%86%E8%AE%93%E5%85%A7%E9%83%A8%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8-https/","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio 設定 http request header 來讓內部容器使用 https","uri":"/2022/04/istio-%E8%A8%AD%E5%AE%9A-http-request-header-%E4%BE%86%E8%AE%93%E5%85%A7%E9%83%A8%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8-https/"},{"categories":["Istio"],"content":"當網路架構在以下狀況時 text Client (get `https://my.domain.com`) -\u003e LB (A10) -\u003e Istio Ingress (TLS Terminating) -\u003e Service (http request schema is http) 由於 Service 端收到的 Http Request 中的協定可能因為憑證管理的方式或其他原因，是會被 A10 或是 Istio Ingress 給過濾掉的。 在這種情況下，可能會導致定義在服務內的一些服務出現錯誤；我實務上碰到的案例是 OAuth OpenIdConnect 的 Redirect Url 在 .Net 6 裡面其實是無法強制複寫成 https 的，加上 A10 那端有被設定強轉，使用 http 的網址並不會通，這時候就會出現錯誤。 以下提供在 Istio 中的解決方式，文章末端也有一些我覺得可能有幫助的一些資料來源讓大家參考。 前面有提到，我自己碰到的狀況如下 由於憑證是設定在 LB (A10) 上面的，當 http request 經過 LB 之後就是一律使用 http (non SSL) 協定進行連線，這導致 Istio Ingress 永遠只會收到 http://my.domain.com 這樣的非 https 網址，再往下進入服務後，.Net 服務所收到的要求更只會進入 80 port。 而由於我公司使用 OAuth 2.0 Code Flow，在使用 OpenIdConnect 設定連線時，微軟套件是無法直接修改整段 Redirect Url 的；儘管修改了，在這樣的架構下也會認證失敗。 在經過幾天的搜尋後找到條有用的 github issue istio github issue 發現只要在 http header 上加入 x-forwarded-proto: https 之後，OpenIdConnect 的套件就會使用 https 去設定 redirect url！ 稍做調整後的 Istio Virtual Service yaml 如下 (其他必要資料請自行調整) yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: -- labels: app.kubernetes.io/name: -- app.kubernetes.io/part-of: -- namespace: -- spec: gateways: - istioGateway hosts: - host.example.com http: - headers: request: set: x-forwarded-proto: https match: - uri: prefix: / route: - destination: host: service-name.namespace.svc.cluster.local subset: v1 port: number: 8080 retries: attempts: 3 perTryTimeout: 10s timeout: 30s 設定好之後果然 OAuth 就通了！可喜可賀~ 可口可樂~~ 其他過程中查到的覺得可能有幫助的資料如下 istio-doc 其它相關設定的 istio doc 頁面 istio doc - show source ip nginx 設定參考 (尚未驗證) 微軟的相關說明-.netcore 3.1 (參考用) 微軟的相關說明-.net 6 (參考用) 直接從 C# 服務中用程式碼設定的做法 (尚未驗證) ===== 未來是希望可以將身分認證等功能全數移往 istio / kubernetes 上的 resource 上設定，降低軟體中對這些網路設定的倚賴，這感覺才有用到 istio 的功能，不然我都不知道我為什麼要使用 istio 了。 ","date":"2022-04-12","objectID":"/2022/04/istio-%E8%A8%AD%E5%AE%9A-http-request-header-%E4%BE%86%E8%AE%93%E5%85%A7%E9%83%A8%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8-https/:0:0","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio 設定 http request header 來讓內部容器使用 https","uri":"/2022/04/istio-%E8%A8%AD%E5%AE%9A-http-request-header-%E4%BE%86%E8%AE%93%E5%85%A7%E9%83%A8%E5%AE%B9%E5%99%A8%E4%BD%BF%E7%94%A8-https/#"},{"categories":["Istio"],"content":"Istio 附帶的 Plugin 安裝","date":"2022-04-10","objectID":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio 附帶的 Plugin 安裝","uri":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/"},{"categories":["Istio"],"content":"Istio 官方安裝套件附帶的套件安裝方式，包含各服務的 Istio Ingress Gateway 設定檔。 ","date":"2022-04-10","objectID":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio 附帶的 Plugin 安裝","uri":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/#"},{"categories":["Istio"],"content":" 安裝 Istio 官方工具中附帶的服務執行以下命令時，需確認目前 bash 所在位置為 istioctl 工具的資料夾中。 建議安裝 prometheus 與 kiali 安裝全部 bash kubectl apply -f samples/addons 個別安裝 prometheus bash kubectl apply -f samples/addons/prometheus.yaml Kiali bash kubectl apply -f samples/addons/kiali.yaml Grafana bash kubectl apply -f samples/addons/grafana.yaml Jaeger bash kubectl apply -f samples/addons/jaeger.yaml Zipkin 與 jaeger 為同質服務，則一安裝即可 bash kubectl apply -f samples/addons/extras/zipkin.yaml Prometheus Operator bash kubectl apply -f samples/addons/extras/prometheus-operator.yaml ","date":"2022-04-10","objectID":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio 附帶的 Plugin 安裝","uri":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/#安裝-istio-官方工具中附帶的服務"},{"categories":["Istio"],"content":" 各個套件的 gateway 設定 參考 : https://istio.io/latest/docs/tasks/observability/gateways/ prometheus (普羅米修斯) bash cat \u003c\u003cEOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: prometheus-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - port: number: 80 name: http-prom protocol: HTTP hosts: - \"prometheus.${INGRESS_DOMAIN}\" --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: prometheus-vs namespace: istio-system spec: hosts: - \"prometheus.${INGRESS_DOMAIN}\" gateways: - prometheus-gateway http: - route: - destination: host: prometheus port: number: 9090 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: prometheus namespace: istio-system spec: host: prometheus trafficPolicy: tls: mode: DISABLE --- EOF Kiali bash cat \u003c\u003cEOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: kiali-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - port: number: 80 name: http-kiali protocol: HTTP hosts: - \"kiali.${INGRESS_DOMAIN}\" --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: kiali-vs namespace: istio-system spec: hosts: - \"kiali.${INGRESS_DOMAIN}\" gateways: - kiali-gateway http: - route: - destination: host: kiali port: number: 20001 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: kiali namespace: istio-system spec: host: kiali trafficPolicy: tls: mode: DISABLE --- EOF Grafana bash cat \u003c\u003cEOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: grafana-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - port: number: 80 name: http-grafana protocol: HTTP hosts: - \"grafana.${INGRESS_DOMAIN}\" --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: grafana-vs namespace: istio-system spec: hosts: - \"grafana.${INGRESS_DOMAIN}\" gateways: - grafana-gateway http: - route: - destination: host: grafana port: number: 3000 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: grafana namespace: istio-system spec: host: grafana trafficPolicy: tls: mode: DISABLE --- EOF 追蹤 (Jaeger/Zipkin) bash cat \u003c\u003cEOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: tracing-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - port: number: 80 name: http-tracing protocol: HTTP hosts: - \"tracing.${INGRESS_DOMAIN}\" --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: tracing-vs namespace: istio-system spec: hosts: - \"tracing.${INGRESS_DOMAIN}\" gateways: - tracing-gateway http: - route: - destination: host: tracing port: number: 80 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: tracing namespace: istio-system spec: host: tracing trafficPolicy: tls: mode: DISABLE --- EOF ","date":"2022-04-10","objectID":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio 附帶的 Plugin 安裝","uri":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/#各個套件的-gateway-設定"},{"categories":["Istio"],"content":" 解除安裝 bash kubectl -n istio-system delete gateway grafana-gateway kiali-gateway prometheus-gateway tracing-gateway kubectl -n istio-system delete virtualservice grafana-vs kiali-vs prometheus-vs tracing-vs kubectl -n istio-system delete destinationrule grafana kiali prometheus tracing ","date":"2022-04-10","objectID":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio 附帶的 Plugin 安裝","uri":"/2022/04/istio-%E9%99%84%E5%B8%B6%E7%9A%84-plugin-%E5%AE%89%E8%A3%9D/#解除安裝"},{"categories":["Kubernetes","Installation"],"content":"Kubernetes 安裝筆記 part.1 : 環境準備","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/"},{"categories":["Kubernetes","Installation"],"content":"Kubernetes Master(Control-plane) / Worker 的 Node 環境準備 資訊 OS: CentOs 7 (kernel = 3.10.1) K8s: v1.24.1 (新安裝時預設使用當下的最新版，因此此版本資訊參考用) 更新時間： 2022/06/11 - use containerd / 不使用 docker 2022/04/10 - kubelet kubeadm kubectl 等工具安裝錯誤的解決方案 ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:0:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#"},{"categories":["Kubernetes","Installation"],"content":" 1 Docker 警告 在 kubernetes 1.24 版之後，由於被拔除了 docker 支援，所以這邊請評估是否還有使用 docker 的需要來選擇安裝，並請參考 containerd 的設定章節 官方文件 清除舊安裝 bash sudo yum remove docker \\ docker-client \\ docker-client-latest \\ docker-common \\ docker-latest \\ docker-latest-logrotate \\ docker-logrotate \\ docker-engine sudo yum remove docker-ce docker-ce-cli containerd.io docker-compose-plugin 更新 yum 以安裝 docker bash sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安裝 docker-ce 與依賴套件 bash sudo yum install docker-ce docker-ce-cli containerd.io docker-compose-plugin 指定版本安裝 列出可用的版本 bash sudo yum list docker-ce --showduplicates | sort -r 安裝指定版本 bash sudo yum install docker-ce-\u003cVERSION_STRING\u003e docker-ce-cli-\u003cVERSION_STRING\u003e containerd.io 啟動 docker 並設定預設啟動 警告 在 kubernetes 1.24 版之後，由於被拔除了 docker 支援，所以這邊可以不用啟用了，並請參考 containerd 的設定章節 bash sudo systemctl start docker sudo systemctl enable docker Docker 磁碟管理模式確認 確認目前 docker 用的磁碟管理模式 [2018 iThome 鐵人賽] Day 28 bash docker info 資訊 正常來說預設安裝後就會使用 overlay2 的磁碟管理模式，若非此模式，可配合下一節的 daemon.json 設定檔來變更設定 Set daemon 新安裝尚未有 daemon.json 檔案時可使用以下語法進行建立 bash sudo mkdir /etc/docker cat \u003c\u003cEOF | sudo tee /etc/docker/daemon.json { \"exec-opts\": [\"native.cgroupdriver=systemd\"], \"log-driver\": \"json-file\", \"log-opts\": { \"max-size\": \"100m\" }, \"storage-driver\": \"overlay2\" } EOF 資訊 此段語法來源 如果有更換使用網段的需求可參考 此篇 編輯現有 daemon.json bash vim /etc/docker/daemon.json 加入 cgroupdriver 設定 可參考官方文件： configuring a cgroup driver kubernetes - docker 資訊 由於新版的 kubernetes 文件對於 docker runtime 的說明中已拔除 daemon.json 設定檔範例。 於 2022 年 02 月 21 日 的測試，仍需要在 daemon.json 檔案中加入 cgroupdriver=systemd 的設定才可正常的初始化 kubernetes 叢集。 若要參考範例可選擇較舊的版本，如 1.22 版文件 (連結)。 json \"exec-opts\": [\"native.cgroupdriver=systemd\"], 加入磁碟管理模式的設定 json \"storage-driver\": \"overlay2\" 資訊 由於現在 Linux OS 新安裝的 docker 都會預設都會使用 overlay2 的磁碟驅動，通常不用特別設定 有時可能也會發生調整為 overlay2 之後就無法啟動 docker 的狀況，所以若有 docker 無法啟動的情況時，可以省略 overlay2 的設定 restart docker bash sudo systemctl enable docker sudo systemctl daemon-reload sudo systemctl restart docker ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:1:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#docker"},{"categories":["Kubernetes","Installation"],"content":" 2 containerd 安裝 資訊 Kubernetes 1.24 以後的版本建議使用此套件 (或其他預設支援的 ORI 套件) 如果有走前一章節的 docker 安裝的話，可以直接跳到 設定 config 更新 yum 以安裝 docker bash sudo yum install -y yum-utils sudo yum-config-manager \\ --add-repo \\ https://download.docker.com/linux/centos/docker-ce.repo 安裝 containerd.io bash sudo yum install containerd.io 設定 config path: /etc/containerd/config.toml 因為使用 yum 安裝 containerd 時的預設設定檔長這樣 (已忽略註解項目) toml disabled_plugins = [\"cri\"] 我們需要把 disabled_plugins 裡面的 cri 移除，並加入 systemd 的相關控制，所以設定檔會變成這樣 toml disabled_plugins = [] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc] [plugins.\"io.containerd.grpc.v1.cri\".containerd.runtimes.runc.options] SystemdCgroup = true 啟動 (重啟) containerd bash sudo systemctl daemon-reload sudo systemctl enable --now containerd # 如果已經有設定啟用 containerd 的話就要用這個 sudo systemctl restart containerd ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:2:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#containerd-安裝"},{"categories":["Kubernetes","Installation"],"content":" 3 Iptables 設定 資訊 kubernetes 1.24 版本後變更 bash cat \u003c\u003cEOF | sudo tee /etc/modules-load.d/k8s.conf overlay br_netfilter EOF sudo modprobe overlay sudo modprobe br_netfilter # sysctl params required by setup, params persist across reboots cat \u003c\u003cEOF | sudo tee /etc/sysctl.d/k8s.conf net.bridge.bridge-nf-call-iptables = 1 net.bridge.bridge-nf-call-ip6tables = 1 net.ipv4.ip_forward = 1 EOF # Apply sysctl params without reboot sudo sysctl --system ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:3:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#iptables-設定"},{"categories":["Kubernetes","Installation"],"content":" 4 關閉 Swap參考文件 使用指令關閉 bash sudo swapoff -a 警告 此命令僅是暫時性關閉，server 重開後仍會啟用 swap，因此需要搭配下一節的設定來完全關閉 swap 永久關閉 swap 註解掉以下命令開啟的檔案中，含有 swap 字樣的行次 bash vim /etc/fstab 用 vim 開啟 /etc/sysctl.conf 檔案，並加入 vm.swappiness=0 此項我在目前有運作的主機上並未進行此設定，但仍可正常運作，但是前述 /etc/fstab 的檔案是確定要修改的 ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:4:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#關閉-swap"},{"categories":["Kubernetes","Installation"],"content":" 5 安裝 kubernetes 所需 cli 工具直接參考官方資料 資訊 以下命令會安裝 kubelet / kubeadm / kubectl 等 cli 工具，並且會調整 selinux 設定 此處紀錄的命令已修正 repo_gpgcheck 問題 (請見下面 Troubleshooting 章節) bash cat \u003c\u003cEOF | sudo tee /etc/yum.repos.d/kubernetes.repo [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 repo_gpgcheck=0 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl EOF # Set SELinux in permissive mode (effectively disabling it) sudo setenforce 0 sudo sed -i 's/^SELINUX=enforcing$/SELINUX=permissive/' /etc/selinux/config sudo yum install -y kubelet kubeadm kubectl --disableexcludes=kubernetes sudo systemctl enable --now kubelet 資訊 預設會安裝以下依賴工具 conntrack-tools cri-tools kubernetes-cni libnetfilter_cthelper libnetfilter_cttimeout libnetfilter_queue socat ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:5:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#安裝-kubernetes-所需-cli-工具"},{"categories":["Kubernetes","Installation"],"content":" 5.1 Troubleshooting如果在安裝 kubelet 等套件時出現以下訊息 text https://packages.cloud.google.com/yum/repos/kubernetes-el7-x86_64/repodata/repomd.xml: [Errno -1] repomd.xml signature could not be verified for kubernetes Trying other mirror. 積極的解決方案 = unknow 消極的解決方案 修改 /etc/yum.repos.d/kubernetes.repo 裡面的 repo_gpgcheck 為 0 text [kubernetes] name=Kubernetes baseurl=https://packages.cloud.google.com/yum/repos/kubernetes-el7-\\$basearch enabled=1 gpgcheck=1 repo_gpgcheck=0 gpgkey=https://packages.cloud.google.com/yum/doc/yum-key.gpg https://packages.cloud.google.com/yum/doc/rpm-package-key.gpg exclude=kubelet kubeadm kubectl ref1: https://github.com/kubernetes/kubernetes/issues/60134 ref2: https://stackoverflow.com/questions/66853387/signature-could-not-be-verified-for-kubernetes-repo ","date":"2022-04-10","objectID":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/:5:1","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Node-Envelopment-Standby"],"title":"Kubernetes 安裝筆記 part.1 : 環境準備","uri":"/2022/04/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.1-%E7%92%B0%E5%A2%83%E6%BA%96%E5%82%99/#troubleshooting"},{"categories":["ArgoCD"],"content":"ArgoCD 安裝筆記","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/"},{"categories":["ArgoCD"],"content":"Argo CD 安裝的紀錄 警告 新版安裝資料待整理，本文版本為 ver 2.2.1 ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#"},{"categories":["ArgoCD"],"content":" ArgoCD Install Memo","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#argocd-install-memo"},{"categories":["ArgoCD"],"content":" 1 Manual Install 資訊 Kubernetes with Istio 的環境下建議參照 kustomization install 的方式進行安裝 download install yaml (option) 指定版本 bash curl -sSL https://raw.githubusercontent.com/argoproj/argo-cd/v2.2.1/manifests/install.yaml -o install-2.2.1.yaml 最新版本 bash curl -sSL https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml -o install-latest.yaml 建立 namespace 純建立 bash kubectl create namespace argocd 含設定 istio 掛車 bash kubectl create namespace argocd kubectl label namespace argocd istio-injection=enabled --overwrite Install to K8s 使用下載版 (指定版本) bash kubectl apply -n argocd -f install-2.2.1.yaml 使用下載版 (最新版本) bash kubectl apply -n argocd -f install-latest.yaml 使用線上指定版 bash kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/v2.2.1/manifests/install.yaml 使用線上最新版 bash kubectl apply -n argocd -f https://raw.githubusercontent.com/argoproj/argo-cd/stable/manifests/install.yaml Install Argo Cli (option) bash curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64 chmod +x /usr/local/bin/argocd Fix Https Problam Reference 編輯發布設定 bash kubectl edit deploy argocd-server -n argocd 找到 spec.containers.command 區段並加入以下內容 yaml spec: containers: - name: argocd-server command: - argocd-server # 加入以下五行，使用 http 連線 - --staticassets - /shared/app - --repo-server - argocd-repo-server:8081 - --insecure 重新佈署 bash kubectl rollout restart deploy -n argocd ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:1:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#manual-install"},{"categories":["ArgoCD"],"content":" 2 Helm InstallOfficial Argo CD Helm Readme 重要：安裝時設定 server.extraArgs={–insecure} 來避開 TLS 憑證，如果要使用 TLS 憑證的話要多一些憑證設定，這邊先略過 bash helm repo add argo https://argoproj.github.io/argo-helm helm install argocd argo/argo-cd -n argocd kubectl create namespace argocd kubectl label namespace argocd istio-injection=enabled --overwrite helm install argocd argo/argo-cd -n argocd --set server.extraArgs={--insecure} ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:2:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#helm-install"},{"categories":["ArgoCD"],"content":" 3 Ingress Install","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:3:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#ingress-install"},{"categories":["ArgoCD"],"content":" 3.1 Use Specific ArgoCD Domain nginx Ingress yaml apiVersion: networking.k8s.io/v1 kind: Ingress metadata: name: argocd-server-ingress namespace: argocd annotations: # kubernetes.io/ingress.class: nginx # nginx.ingress.kubernetes.io/force-ssl-redirect: \"true\" # nginx.ingress.kubernetes.io/ssl-passthrough: \"true\" spec: ingressClassName: nginx rules: - host: argocd.\u003cdomain\u003e http: paths: - pathType: Prefix path: / backend: service: name: argocd-server port: number: 80 Istio Ingress Reference Gateway yaml yaml apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: argocd-gateway namespace: argocd spec: selector: istio: ingressgateway servers: - hosts: - argocd.\u003cdomain\u003e port: name: http # port 要用 ingressgateway 中，port = 80 的那組設定的 TargetPort number: 8080 protocol: HTTP # 如果要強轉 HTTPS # tls: # httpsRedirect: true - hosts: # 這邊這樣設定只是想讓 istio 不會跳相同 host 的警告 - argocd/argocd.\u003cdomain\u003e port: name: https # port 要用 ingressgateway 中，port = 443 的那組設定的 TargetPort number: 8443 protocol: HTTPS tls: mode: PASSTHROUGH # 另外的設定方法，待測試 # tls: # credentialName: argocd-server-tls # argocd server 會自動讀取這個名稱的 k8s secrets # mode: SIMPLE VirtualService yaml 資訊 含有 https 導流的設定方式要研究一下 yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: argocd-vs namespace: argocd spec: hosts: - argocd.\u003cdomain\u003e gateways: - argocd-gateway http: - route: - destination: host: argocd-server.argocd.svc.cluster.local port: number: 80 ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:3:1","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#use-specific-argocd-domain"},{"categories":["ArgoCD"],"content":" 3.2 Use Relative ArgoCD Path 警告 暫時測不到 \u003cdomain\u003e/argocd/ 這種相對路徑的 URL 設定 nginx Ingress 待補 Istio Ingress Gateway yaml yaml apiVersion: networking.istio.io/v1beta1 kind: Gateway metadata: name: argocd-gateway namespace: argocd spec: selector: istio: ingressgateway servers: - hosts: - \u003cdomain\u003e port: name: http # port 要用 ingressgateway 中，port = 80 的那組設定的 TargetPort number: 8080 protocol: HTTP # 如果要強轉 HTTPS # tls: # httpsRedirect: true - hosts: # 這邊這樣設定只是想讓 istio 不會跳相同 host 的警告 - argocd/\u003cdomain\u003e port: name: https # port 要用 ingressgateway 中，port = 443 的那組設定的 TargetPort number: 443 protocol: HTTPS tls: mode: PASSTHROUGH # 另外的設定方法，待測試 # tls: # credentialName: argocd-server-tls # argocd server 會自動讀取這個名稱的 k8s secrets # mode: SIMPLE VirtualService yaml 資訊 含有 https 導流的設定方式要研究一下 yaml apiVersion: networking.istio.io/v1beta1 kind: VirtualService metadata: name: argocd-vs namespace: argocd spec: hosts: - \u003cdomain\u003e gateways: - argocd-gateway http: - route: - destination: host: argocd-server.argocd.svc.cluster.local port: number: 80 ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:3:2","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#use-relative-argocd-path"},{"categories":["ArgoCD"],"content":" 4 kustomization Install With Istio (Recommend when use istio)此方法主要參考以下三個連結 說明文件 官方 issues 第三方的主要 GitRepo 資訊 這邊的 kustomization yaml 同時設定了 argoproj-lab 的擴充 預先準備 依據 Manual Command Install 章節準備好官方 ArgoCD 安裝 Yaml 與 Kubernetes Namespace 依據 Ingress Install 章節準備好 Istio 使用的 VisualService 與 Gateway 準備 kustomization yaml yaml apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization namespace: argocd resources: - install-2.2.1.yaml - VirtualService.yaml - Gateway.yaml patchesStrategicMerge: - istio_patches.yaml components: # extensions controller component - https://github.com/argoproj-labs/argocd-extensions/manifests 準備 istio patch yaml 資訊 這邊準備的 yaml 除了預先設定排除 https 之外，就是要設定每個部屬出去的組件的版本號與應用程式名稱，以便 Istio 可以正確追蹤；在使用 [Manual Command Install](#Manual-Command-Install) + [Ingress Install](#Ingress-Install) 的方式安裝時，Istio 會發出因為沒有版本號與應用程式的 Label 而無法追蹤的錯誤。 警告 此處提供的 yaml 內容須依據實際安裝的版本去修改版本號，例如在本文件中使用的 Argo CD 版本為 v2.2.1 版，就要將相關版本設定為 v2.2.1。而 Redis 與其他套件的部分，建議參考官方安裝文件中使用的版號進行設定，盡可能使 label 中的版號與實際使用的套件版本相符。 yaml apiVersion: apps/v1 kind: Deployment metadata: labels: app.kubernetes.io/component: server app.kubernetes.io/name: argocd-server app.kubernetes.io/part-of: argocd app: argocd-server version: v2.2.1 name: argocd-server spec: template: spec: containers: - name: argocd-server command: - argocd-server - --staticassets - /shared/app - --insecure --- apiVersion: apps/v1 kind: Deployment metadata: labels: app.kubernetes.io/component: repo-server app.kubernetes.io/name: argocd-repo-server app.kubernetes.io/part-of: argocd app: argocd-repo-server version: v2.2.1 name: argocd-repo-server spec: template: metadata: labels: app: argocd-repo-server version: v2.2.1 --- apiVersion: apps/v1 kind: Deployment metadata: labels: app.kubernetes.io/component: redis app.kubernetes.io/name: argocd-redis app.kubernetes.io/part-of: argocd app: argocd-redis version: v6.2.4 name: argocd-redis spec: template: metadata: labels: app: argocd-redis version: v6.2.4 --- apiVersion: apps/v1 kind: Deployment metadata: labels: app.kubernetes.io/component: dex-server app.kubernetes.io/name: argocd-dex-server app.kubernetes.io/part-of: argocd app: argocd-dex-server version: v2.30.0 name: argocd-dex-server spec: template: metadata: labels: app: argocd-dex-server version: v2.30.0 --- apiVersion: apps/v1 kind: StatefulSet metadata: labels: app.kubernetes.io/component: application-controller app.kubernetes.io/name: argocd-application-controller app.kubernetes.io/part-of: argocd app: argocd-application-controller version: v2.2.1 name: argocd-application-controller spec: template: metadata: labels: app: argocd-application-controller version: v2.2.1 --- apiVersion: v1 kind: Service metadata: name: argocd-dex-server spec: # expose container ports to istio network ports: - name: http port: 5556 protocol: TCP targetPort: 5556 - name: http-grpc port: 5557 protocol: TCP targetPort: 5557 - name: http-metrics port: 5558 protocol: TCP targetPort: 5558 --- apiVersion: v1 kind: Service metadata: name: argocd-metrics spec: # expose container ports to istio network ports: - name: http-metrics port: 8082 protocol: TCP targetPort: 8082 --- apiVersion: v1 kind: Service metadata: name: argocd-repo-server spec: # expose container ports to istio network ports: - name: https-server port: 8081 protocol: TCP targetPort: 8081 - name: http-metrics port: 8084 protocol: TCP targetPort: 8084 --- apiVersion: v1 kind: Service metadata: name: argocd-server-metrics spec: # expose container ports to istio network ports: - name: http-metrics port: 8083 protocol: TCP targetPort: 8083 --- apiVersion: v1 kind: Service metadata: name: argocd-server spec: ports: - name: http-argocd-server port: 80 protocol: TCP targetPort: 8080 # delete https port - port: 443 $patch: delete 安裝 警告 建議前述準備的 yaml 檔案統一放在專門的資料夾 bash kubectl apply -k ./ ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:4:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#kustomization-install-with-istio-recommend-when-use-istio"},{"categories":["ArgoCD"],"content":" CLI Tool官方文件 警告 CLI 不需要安裝在 ArgoCD 所在的叢集主機 (或 kubernetes master server)，但是有些 CLI 命令倚賴 kube config 來取得叢集資料，如果 CLI 裝在沒有 kube config 的環境時，有些命令會出錯 ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#cli-tool"},{"categories":["ArgoCD"],"content":" 1 Install - Linux Download Latest with curl (Linux) bash curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/latest/download/argocd-linux-amd64 chmod +x /usr/local/bin/argocd Download Concrete Version with curl (Linux) bash curl -sSL -o /usr/local/bin/argocd https://github.com/argoproj/argo-cd/releases/download/v2.2.1/argocd-linux-amd64 chmod +x /usr/local/bin/argocd ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:1:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#install---linux"},{"categories":["ArgoCD"],"content":" Manage","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#manage"},{"categories":["ArgoCD"],"content":" 1 Remote Cluster 參考 Kubernetes Multi-Cluster 中的說明，調整 ArgoCD 所在的網路叢集的 Kubernetes config，加入外部叢集資訊 確認外部叢集的名稱以供後續 ArgoCD 加入外部叢集時使用 bash kubectl config get-contexts -o name 使用 ArgoCD CLI 登入 ArgoCD bash argocd login \u003cARGOCD_SERVER\u003e 加入外部叢集 bash argocd cluster add \u003cremote-cluster name\u003e 現在可以在 UI 中看到外部叢集了 CLI 參考 bash # List all known clusters in JSON format: argocd cluster list -o json # Add a target cluster configuration to ArgoCD. The context must exist in your kubectl config: argocd cluster add \u003ccluster name\u003e # Get specific details about a cluster in plain text (wide) format: argocd cluster get \u003ccluster name\u003e -o wide # Remove a target cluster context from ArgoCD argocd cluster rm \u003ccluster name\u003e ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:1:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#remote-cluster"},{"categories":["ArgoCD"],"content":" 2 User Get Default Admin Password bash kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d; echo 警告 不完整 使用官方提供的命令取得管理員密碼，登入系統後應修改密碼 bash kubectl -n argocd get secret argocd-initial-admin-secret -o jsonpath=\"{.data.password}\" | base64 -d 編輯 ConfigMap bash kubectl edit cm argocd-cm -n argocd 找到 data 區段，加入使用者 yaml data: accounts.\u003cuser\u003e: apiKey,login # 加入這個 application.instanceLabelKey: argocd.argoproj.io/instance url: \u003cargocd server url\u003e # 這個可以順便改一下 到 \u003cargocd server url\u003e/settings/accounts 建立登入的 Token (密碼的更新方式待測試) ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:2:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#user"},{"categories":["ArgoCD"],"content":" Extension Install","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#extension-install"},{"categories":["ArgoCD"],"content":" 1 Core Install官方擴充套件 建議使用 Kustomization 方式安裝，同時，安裝時會需要使用到 Git，請確認系統內已安裝 Git。 kustomization yaml (Base on kustomization Install With Istio) yaml apiVersion: kustomize.config.k8s.io/v1beta1 kind: Kustomization namespace: argocd resources: - install-2.2.1.yaml - VirtualService.yaml - Gateway.yaml patchesStrategicMerge: - istio_patches.yaml components: # extensions controller component - https://github.com/argoproj-labs/argocd-extensions/manifests ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:1:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#core-install"},{"categories":["ArgoCD"],"content":" 2 Rollout-extension installArgo Rollout dashboard into the Argo CD Web UI. download yaml bash curl https://raw.githubusercontent.com/argoproj-labs/rollout-extension/v0.1.0/manifests/install.yaml -o argocd-rollout-extension.yaml apply bash kubectl apply -n argocd -f argocd-rollout-extension.yaml ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:2:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#rollout-extension-install"},{"categories":["ArgoCD"],"content":" ReferenceArgo Cd Official Startup Argo Cd Official TLS Configuration Argo Cd Official Startup-Github Argo Cd Github Release Page ","date":"2022-04-04","objectID":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/:0:0","series":null,"tags":["Install"],"title":"ArgoCD 安裝筆記","uri":"/2022/04/argocd-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98/#reference"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":"使用 ArgoCD 建立 Kubernetes 基礎建設","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":"當一個叢集建立好之後總會需要安裝 Metrics 相關服務，這邊使用 ArgoCD 建立相關應用程式，讓 Cluster 加入之後就可以直接用 ArgoCD 部屬 Metrics-Server / Prometheus-adapter 等服務。 CLI Command - 設定 Cluster/加入 Repository Metrics-Server 的 Application 設定 yaml Prometheus-adapter 的 Application 設定 yaml ","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/:0:0","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/#"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":" ArgoCli 設定 Cluster bash argocd cluster add srvk8s-admin@srvk8s --name Master-Cluster 加入 Repo bash argocd repo add https://prometheus-community.github.io/helm-charts --type helm --name Prometheus argocd repo add https://kubernetes.github.io/dashboard --type helm --name kubernetes-dashboard argocd repo add https://kubernetes-sigs.github.io/metrics-server --type helm --name metrics-server ","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/:0:0","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/#argocli"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":" Metrics-Serverhelm repository ArgoCD Application yaml yaml apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: metrics-server-master-cluster spec: destination: name: Master-Cluster namespace: kube-system server: '' source: path: '' repoURL: 'https://kubernetes-sigs.github.io/metrics-server/' targetRevision: 3.8.2 chart: metrics-server helm: valueFiles: - values.yaml parameters: - name: metrics.enabled value: 'true' values: |- args: - --kubelet-insecure-tls project: cluster-infra syncPolicy: syncOptions: - CreateNamespace=true - PruneLast=true ","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/:0:0","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/#metrics-server"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":" Prometheus-adapter 警告 此方法搭配 Istio \u0026 Istio 其中佩附的 Prometheus，是 Metrics-Server 的替代作法。 由於 metrics-server 安裝後無法在 lens (kubernetes IDE) 上看到各個 pod 的資源狀態，如果 cluster 的資源夠多，我會建議使用這個做法。 yaml apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: prometheus-adapter-Master-Cluster spec: destination: name: Master-Cluster namespace: istio-system server: '' source: path: '' repoURL: 'https://prometheus-community.github.io/helm-charts' targetRevision: 3.0.1 chart: prometheus-adapter helm: valueFiles: - values.yaml values: |- rules: default: true resource: cpu: containerQuery: sum(rate(container_cpu_usage_seconds_total{\u003c\u003c.LabelMatchers\u003e\u003e, container!=\"\"}[5m])) by (\u003c\u003c.GroupBy\u003e\u003e) nodeQuery: sum(rate(container_cpu_usage_seconds_total{\u003c\u003c.LabelMatchers\u003e\u003e, id='/'}[5m])) by (\u003c\u003c.GroupBy\u003e\u003e) resources: overrides: node: resource: node namespace: resource: namespace pod: resource: pod containerLabel: container memory: containerQuery: sum(container_memory_working_set_bytes{\u003c\u003c.LabelMatchers\u003e\u003e, container!=\"\"}) by (\u003c\u003c.GroupBy\u003e\u003e) nodeQuery: sum(container_memory_working_set_bytes{\u003c\u003c.LabelMatchers\u003e\u003e,id='/'}) by (\u003c\u003c.GroupBy\u003e\u003e) resources: overrides: node: resource: node namespace: resource: namespace pod: resource: pod containerLabel: container window: 5m custom: - seriesQuery: '{__name__=~\"istio_requests_total\"}' seriesFilters: [] resources: overrides: kubernetes_namespace: resource: namespace kubernetes_pod_name: resource: pod destination_service_name: resource: service name: matches: \"^(.*)_total\" as: \"${1}_per_min\" metricsQuery: sum(increase(\u003c\u003c.Series\u003e\u003e{\u003c\u003c.LabelMatchers\u003e\u003e}[1m])) by (\u003c\u003c.GroupBy\u003e\u003e) parameters: - name: prometheus.url value: 'http://prometheus.istio-system.svc.cluster.local' project: cluster-infra syncPolicy: syncOptions: [] ","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/:0:0","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/#prometheus-adapter"},{"categories":["ArgoCD","Kubernetes","kubernetes-cluster-infrastructure"],"content":" Kubernetes Dashboard 危險 這個設定我尚未完成測試使用，僅成功安裝 \u0026 利用 Lens 的 Forward 功能連進去，但是登入的部分碰到困難。 另外我的環境都有 istio，之後等測試 OK 的時候會再補上 istio 的 ingress 相關設定 yaml apiVersion: argoproj.io/v1alpha1 kind: Application metadata: name: kube-dashboard-master-cluster spec: destination: name: Master-Cluster namespace: kube-dashboard server: '' source: path: '' repoURL: 'https://kubernetes.github.io/dashboard/' targetRevision: 5.3.1 chart: kubernetes-dashboard helm: valueFiles: - values.yaml project: cluster-infra syncPolicy: syncOptions: - PruneLast=true - CreateNamespace=true ","date":"2022-04-04","objectID":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/:0:0","series":null,"tags":["Kubernetes","kubernetes-cluster-infrastructure","metrics-server","Prometheus","Prometheus-adapter","Kubernetes-dashboard"],"title":"使用 ArgoCD 建立 Kubernetes 基礎建設","uri":"/2022/04/%E4%BD%BF%E7%94%A8-argocd-%E5%BB%BA%E7%AB%8B-kubernetes-%E5%9F%BA%E7%A4%8E%E5%BB%BA%E8%A8%AD/#kubernetes-dashboard"},{"categories":["Istio"],"content":"Istio Sidecar Proxy 未啟動時服務無法連網問題處理","date":"2022-03-30","objectID":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio Sidecar Proxy 未啟動時服務無法連網問題處理","uri":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/"},{"categories":["Istio"],"content":"前段時間在工作上碰到服務部署後沒辦法連上網路，但是容器重啟後就一切正常。 在查過資料後發現原來是因為 Istio Sidecar Proxy 尚未完成啟動時，後面的服務會無法連上網路的問題，這篇記錄解決辦法。 ","date":"2022-03-30","objectID":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/:0:0","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio Sidecar Proxy 未啟動時服務無法連網問題處理","uri":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/#"},{"categories":["Istio"],"content":" 更新 Istio 的 ConfigMap在 Istio Config 中的 mesh 設定中加入以下設定 yaml holdApplicationUntilProxyStarts: true 最後加完預設的內容應該會長這樣 yaml defaultConfig: holdApplicationUntilProxyStarts: true discoveryAddress: istiod.istio-system.svc:15012 proxyMetadata: {} tracing: zipkin: address: zipkin.istio-system:9411 enablePrometheusMerge: true rootNamespace: istio-system trustDomain: cluster.local ","date":"2022-03-30","objectID":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/:0:0","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio Sidecar Proxy 未啟動時服務無法連網問題處理","uri":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/#更新-istio-的-configmap"},{"categories":["Istio"],"content":" Reference stackoverflow:connection-refused-error-in-outbound-request-in-k8s-app-container-istio Istio Github Issues#33911 Istio Github Issues#11130 知乎-关于Istio Proxy生命周期的两点注意事项 ","date":"2022-03-30","objectID":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/:0:0","series":[],"tags":["Istio","service-mesh","Troubleshooting"],"title":"Istio Sidecar Proxy 未啟動時服務無法連網問題處理","uri":"/2022/03/istio-sidecar-proxy-%E6%9C%AA%E5%95%9F%E5%8B%95%E6%99%82%E6%9C%8D%E5%8B%99%E7%84%A1%E6%B3%95%E9%80%A3%E7%B6%B2%E5%95%8F%E9%A1%8C%E8%99%95%E7%90%86/#reference"},{"categories":["Kubernetes"],"content":"Kubernetes 與 Docker 的網段設定調整","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/"},{"categories":["Kubernetes"],"content":"此篇記錄 Kubernetes ( use Weave-cni ) 的預設網段以及 Docker 預設網段，並且說明如何進行網段調整。 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#"},{"categories":["Kubernetes"],"content":" 全預設網段Docker (custom bridge) 為使用 ‘docker create network’ 命令後產生的新的 docker 內部網路。 由於預設網路 (default bridge) 中的 docker container 無法使用網路別名進行溝通，必須自行建立一個自訂網路來使用網路別名。 依照 Docker 產生新網路的邏輯，在預設不特別給定 subnet 的情況下，會在第二碼逐步遞增；未測試預設使用的網段最大值，正常來說也不大需要開到這麼多網段。 Used For Subnet GenMask Start End Kubernetes (Weave-cni) 10.32.0.0/12 255.240.0.0 10.32.0.1 10.47.255.254 Docker (default bridge) 172.17.0.0/16 255.255.0.0 172.17.0.1 172.17.255.254 Docker (custom bridge1) 172.18.0.0/16 255.255.0.0 172.18.0.1 172.18.255.254 Docker (custom bridge2) 172.19.0.0/16 255.255.0.0 172.18.0.1 172.18.255.254 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#全預設網段"},{"categories":["Kubernetes"],"content":" Weave.net cni 預設網段調整方式安裝 Weave.net cni 時設定 安裝語法如下 bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#weavenet-cni-預設網段調整方式"},{"categories":["Kubernetes"],"content":" Docker 預設網段調整方式使用 vi 編輯 /etc/docker/daemon.json json { \"default-address-pools\": [ {\"base\":\"10.48.0.0/14\",\"size\":16} ], \"bip\": \"10.48.0.1/16\" } ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#docker-預設網段調整方式"},{"categories":["Kubernetes"],"content":" 1 default-address-pools 說明base = 可使用網段範圍 size = 每一個 bridge 網段大小 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:1:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#default-address-pools-說明"},{"categories":["Kubernetes"],"content":" 2 base 設定 10.48.0.0/14 時 Docker 可使用的網段如下 Used For Subnet GenMask Start End Docker (default bridge) 10.48.0.0/16 255.240.0.0 10.48.0.1 10.48.255.254 Docker (custom bridge) 10.49.0.0/16 255.255.0.0 10.49.0.1 10.49.255.254 Docker (custom bridge) 10.50.0.0/16 255.255.0.0 10.50.0.1 10.50.255.254 Docker (custom bridge) 10.51.0.0/16 255.255.0.0 10.51.0.1 10.51.255.254 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:2:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#base-設定-10480014-時-docker-可使用的網段如下"},{"categories":["Kubernetes"],"content":" 3 base 設定 10.48.0.0/15 時 Docker 可使用的網段如下 Used For Subnet GenMask Start End Docker (default bridge) 10.48.0.0/16 255.255.0.0 10.48.0.1 10.48.255.254 Docker (custom bridge) 10.49.0.0/16 255.255.0.0 10.49.0.1 10.49.255.254 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:3:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#base-設定-10480015-時-docker-可使用的網段如下"},{"categories":["Kubernetes"],"content":" 4 調整完畢後的網段表 - 以 base 設定 10.48.0.0/15 為例 Used For Subnet GenMask Start End Kubernetes (Weave-cni) 10.32.0.0/12 255.240.0.0 10.32.0.1 10.47.255.254 Docker (default bridge) 10.48.0.0/16 255.255.0.0 10.48.0.1 10.48.255.254 Docker (custom bridge) 10.49.0.0/16 255.255.0.0 10.49.0.1 10.49.255.254 ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:4:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#調整完畢後的網段表---以-base-設定-10480015-為例"},{"categories":["Kubernetes"],"content":" Reference IP 網段計算器 docker defautl subnet Weave.net CNI default subnet ","date":"2022-03-30","objectID":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["Network","Docker"],"title":"Kubernetes \u0026 Docker 的預設網段筆記","uri":"/2022/03/kubernetes-docker-%E7%9A%84%E9%A0%90%E8%A8%AD%E7%B6%B2%E6%AE%B5%E7%AD%86%E8%A8%98/#reference"},{"categories":["Kubernetes","Installation"],"content":"Kubernetes 安裝筆記 part.2 : 叢集初始化","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/"},{"categories":["Kubernetes","Installation"],"content":"使用 Kubeadm 初始化 Kubernetes Cluster. 資訊 OS: CentOs 7 (kernel = 3.10.1) K8s: v1.23.4 (新安裝時預設使用當下的最新版，因此此版本資訊參考用) ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:0:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#"},{"categories":["Kubernetes","Installation"],"content":" Init Kubernetes Cluster 此篇安裝 kubernetes 的方法是使用 kubeadm ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:0:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#init-kubernetes-cluster"},{"categories":["Kubernetes","Installation"],"content":" 1 kubeadm init安裝時建議 增加 --upload-certs 參數，這樣未來要加入其他 Master (Control plane) Node 以建立 HA 環境時方便共用憑證。 設定 –control-plane-endpoint ，並使用已註冊於 DNS 的 endpoint，可以讓叢集內的 Node 不用倚賴 Node IP 來與 Master 溝通 bash kubeadm init --control-plane-endpoint=\u003cserver in dns\u003e --upload-certs 其它 Node 要用 Master 形式加入的話就可以用下面這個命令 bash kubeadm join internal.k8s.master:6443 --token \u003ctoken\u003e \\ --discovery-token-ca-cert-hash sha256:\u003chash\u003e \\ --control-plane --certificate-key \u003ccert\u003e 其它 Node 要用 worker 的形式加入 cluster 的話要使用以下命令 bash kubeadm join internal.k8s.master:6443 --token \u003ctoken\u003e \\ --discovery-token-ca-cert-hash sha256:\u003chash\u003e 重新產生 Token bash kubeadm token create 取得 cert bash openssl x509 -pubkey -in /etc/kubernetes/pki/ca.crt | openssl rsa -pubin -outform der 2\u003e/dev/null | \\ openssl dgst -sha256 -hex | sed 's/^.* //' ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:1:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#kubeadm-init"},{"categories":["Kubernetes","Installation"],"content":" 2 Single Node Setting需要在 master node 中部屬服務時需要下這個指令 bash kubectl taint nodes --all node-role.kubernetes.io/master- ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:2:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#single-node-setting"},{"categories":["Kubernetes","Installation"],"content":" 3 部屬 weave 網路 (CNI) 部屬 weave 網路 (CNI) 查看 weave net pods 的部屬設定 bash kubectl describe -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 部屬 weave net pods bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 移除 weave net pods 的部屬 bash kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\" 部屬 weave net 的時候如果無法部屬成功，可能是因為機器上已有路由表 REF 1. https://www.weave.works/docs/net/latest/kubernetes/kube-addon/#troubleshooting REF 2. https://tonybai.com/2016/12/30/install-kubernetes-on-ubuntu-with-kubeadm-2/ weavenet 預設使用的路由為 10.32.0.0/12 (可用 ip 網段範圍為 10.32.0.0 ~ 10.47.0.0)，須注意要加入 k8s 叢集的主機上是否有路由衝突，若有，會導致新加入的機器上面的 weavenet 服務部屬失敗 可以使用以下命令確認路由 bash netstat -rn 修改後的 apply 命令 bash kubectl apply -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" kubectl delete -f \"https://cloud.weave.works/k8s/net?k8s-version=$(kubectl version | base64 | tr -d '\\n')\u0026env.IPALLOC_RANGE=172.30.0.0/16\" 安裝時因為 weave net image 的來源不是 docker hub，而是 “ghcr.io”，如果有網路環境問題的話，所以可以在 docker daemon 中調整設定 json \"insecure-registries\":[\"ghcr.io\"], ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:3:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#部屬-weave-網路-cni"},{"categories":["Kubernetes","Installation"],"content":" 4 安裝 HELM (建議) kubernetes 通常使用 HELM 來安裝套件，建議在 master 上安裝 helm 工具 bash curl -fsSL -o get_helm.sh https://raw.githubusercontent.com/helm/helm/main/scripts/get-helm-3 chmod 700 get_helm.sh ./get_helm.sh ","date":"2022-02-21","objectID":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/:4:0","series":["kubernetes-install-memo"],"tags":["Kubernetes","Cluster-Install","Installation","Cluster-Initializing"],"title":"Kubernetes 安裝筆記 part.2 : 叢集初始化","uri":"/2022/02/kubernetes-%E5%AE%89%E8%A3%9D%E7%AD%86%E8%A8%98-part.2-%E5%8F%A2%E9%9B%86%E5%88%9D%E5%A7%8B%E5%8C%96/#安裝-helm-建議"},{"categories":["C#","EF-Core"],"content":"EF Core 中建立自訂關聯，常用於實際資料庫中的 Table 未建立關聯的情境","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/"},{"categories":["C#","EF-Core"],"content":"當 Db 內的 Table 都沒有設定關聯，又希望在不調整 Db 的情況下用操作有關連 Table 的方法使用 EF Core 時，可以在 EF Core 所使用的 Entity 與 Entity Configuration 中自訂關聯性，EF Core 會自行調整 Sql 語法 (使用 Left join 或其它 join 語法) 來加入資料。 EF Power Tool 產生的 Entity / Entity Configuration 預設皆有引入 partial 關鍵字，因此，為了區別工具產生的 code 與自訂的 code，我們可以另外建立新的檔案處理自定義的部分。 本篇範例為 一對一、一對多 的設定方式。 警告 TODO: 示範用程式碼待補 (2022-02-06) ","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/:0:0","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/#"},{"categories":["C#","EF-Core"],"content":" 使用的專案結構 Db.Repository 專案結構樹 結構樹 text . ├── Configurations ├── Entities ├── [db name]Context.cs └── efpt.config.json 專案內部資料夾說明 資料夾 說明 Configurations EF Power Tool 產生的 Entity 設定檔 Entities EF Power Tool 產生的 Entity 檔 [db name]Context.cs EF Core DbContext By Db efpt.config.json EF Core Power Tool 設定檔，除了進行 Entity 增減外，不應有其它變更 以下操作均使用 EF Core 5.0 ","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/:0:0","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/#使用的專案結構"},{"categories":["C#","EF-Core"],"content":" Entity 調整在 Db.Repository 專案中，找到想要加入自訂關聯的 Entity，並建立一個新的檔案，名為 {EntityName}.CustomProperty.cs。 註：新增的檔案後續的字節 (CustomProperty) 可以依據該檔案內放置的項目進行調整，本次以 CustomProperty 命名是因內容存放自定義屬性。 EF Power Tool 產生的 Entity File cs //File: Db.Repository/Entities/MainTable.cs public partial class MainTable { public int MainId{ get; set; } } //File: Db.Repository/Entities/OneToManySubTable.cs public partial class OneToManySubTable { public int MainId{ get; set; } public int SubId{ get; set; } } //File: Db.Repository/Entities/OneToOneSubTable.cs public partial class OneToOneSubTable { public int MainId{ get; set; } public int SubId{ get; set; } } 手動新增的 Partial File cs //File: Db.Repository/Entities/MainTable.CustomProperty.cs public partial class MainTable { public MainTable() { this.OneToManySubItems = new HashSet\u003cOneToManySubTable\u003e(); } public virtual ICollection\u003cOneToManySubTable\u003e OneToManySubItems { get; set; } public virtual OnoToOneSubTable OneToOneSubItem { get; set; } } //File: Db.Repository/Entities/OneToManySubTable.CustomProperty.cs public partial class OneToManySubTable { public virtual MainTable Header { get; set; } } //File: Db.Repository/Entities/OneToOneSubTable.CustomProperty.cs public partial class OneToOneSubTable { public virtual MainTable Header { get; set; } } ","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/:0:0","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/#entity-調整"},{"categories":["C#","EF-Core"],"content":" Entity Configuration 調整在 Db.Repository 專案中，找到想要加入自訂關聯的 Entity Configuration，並建立一個新的檔案，名為 {EntityName}Configuration.Partial.cs。 註：新增的檔案後續的字節 (Partial) 可以依據該檔案內放置的項目進行調整，本次以 Partial 命名是因 “關聯” 的英文過長，而採用較短且符合檔案目的的 Partial EF Power Tool 產生的 Entity Configuration cs //File: Db.Repository/Configurations/OneToOneSubTableConfiguration.cs public partial class OneToOneSubTableConfiguration : IEntityTypeConfiguration\u003cOneToOneSubTable\u003e { public void Configure(EntityTypeBuilder\u003cOneToOneSubTable\u003e entity) { entity.HasKey(e =\u003e e.SubId); entity.ToTable(\"OneToOneSubTable\", \"dbo\"); entity.HasComment(\"一對一子表\"); entity.Property(e =\u003e e.SubId).HasColumnName(\"SubId\"); this.OnConfigurePartial(entity); } partial void OnConfigurePartial(EntityTypeBuilder\u003cOneToOneSubTable\u003e entity); } //File: Db.Repository/Configurations/OneToManySubTableConfiguration.cs public partial class OneToManySubTableConfiguration : IEntityTypeConfiguration\u003cOneToManySubTable\u003e { public void Configure(EntityTypeBuilder\u003cOneToManySubTable\u003e entity) { entity.HasKey(e =\u003e e.SubId); entity.ToTable(\"OneToManySubTable\", \"dbo\"); entity.HasComment(\"一對多子表\"); entity.Property(e =\u003e e.SubId).HasColumnName(\"SubId\"); this.OnConfigurePartial(entity); } partial void OnConfigurePartial(EntityTypeBuilder\u003cOneToManySubTable\u003e entity); } 手動新增的 Partial File 補充：OnDelete 的參數可參照 微軟官方 的說明調整設定 cs //File: Db.Repository/Configurations/OneToOneSubTableConfiguration.Partial.cs public partial class OneToOneSubTableConfiguration : IEntityTypeConfiguration\u003cOneToOneSubTable\u003e { partial void OnConfigurePartial(EntityTypeBuilder\u003cOneToOneSubTable\u003e entity) { entity.HasOne(d =\u003e d.Header) //設定 OneToOneSubTable 這個 Entity Header 這個屬性是屬於外部資料 .WithOne(p =\u003e p.OneToOneSubItem) //設定前一行 HasOne 中選擇的屬性 (Header) 的型別 (MainTable) 中的 OneToOneSubItem 屬性對應自己 (OneToOneSubTable) .HasForeignKey(d =\u003e d.MainId) //設定自己 (OneToOneSubTable) 的哪一個屬性是紀錄 Header 的 PK .OnDelete(DeleteBehavior.ClientSetNull); //設定資料刪除後的處理方式 (Header 被刪掉後是否要跟著被刪掉) } } //File: Db.Repository/Configurations/OneToManySubTableConfiguration.Partial.cs public partial class OneToManySubTableConfiguration : IEntityTypeConfiguration\u003cOneToManySubTable\u003e { partial void OnConfigurePartial(EntityTypeBuilder\u003cOneToManySubTable\u003e entity) { //各方法說明皆與 OneToOne 相同，只是因為 OneToMany 是一對多，所以第二行設定從 WithOne 改為 WithMany entity.HasOne(d =\u003e d.Header) .WithMany(p =\u003e p.OneToManySubItems) .HasForeignKey(d =\u003e d.SubId) .OnDelete(DeleteBehavior.ClientSetNull); } } ","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/:0:0","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/#entity-configuration-調整"},{"categories":["C#","EF-Core"],"content":" 使用方式本章節提供三種 EF Core 操作 Db 的方法，可依需要自行選擇做法。 EF Core 中，觸發有關聯的 SubTable 需要調用 Include / ThenInclude 方法。 直接轉成輸出用的 Dto 物件寫法 此寫法可自訂輸出欄位，減少 SqlServer \u003c-\u003e WebService 間的資料傳輸量 cs private async Task\u003cIEnumerable\u003cMainTableDto\u003e\u003e GetAllMainTableDtos() { return await this._testContext.MainTables .AsNoTracking() .Get() .Include(o=\u003eo.OneToManySubItems) .Include(o=\u003eo.OneToOneSubItem) .Select(o =\u003e new MainTableDto { MainId = o.MainId, // 這邊允許使用 AutoMapper 直接映照欄位，如註解，但若 Sub Table 中只需要特定欄位的話，則建議使用此處範例使用的寫法 // OneToManySubItems = this._mapper.Map\u003cIEnumerable\u003cOneToManySubTableDto\u003e\u003e(o.OneToManySubItems) OneToManySubItems = o.OneToManySubItems.Select(m=\u003enew OneToManySubTableDto { SubId = m.SubId, MainId = m.MainId }), // OneToOneSubItem = this._mapper.Map\u003cOneToOneSubTableDto\u003e(o.OneToOneSubItem) OneToOneSubItem = new OneToOneSubTableDto { SubId = o.OneToOneSubItem.SubId, MainId = o.OneToOneSubItem.MainId }) }).ToListAsync(); } 完整依據 Table Entity 內容轉出 Db 資料，再自行組合 Service 輸出用的 Dto 物件寫法 此寫法適合在需要一些額外的欄位判斷事情，但是那些欄位又不需要輸出的情境 cs private async Task\u003cIEnumerable\u003cMainTableDto\u003e\u003e GetAllMainTableDtos() { var mainTableList = await this._testContext.MainTables .AsNoTracking() .Get() .Include(o=\u003eo.OneToManySubItems) .Include(o=\u003eo.OneToOneSubItem) .ToListAsync(); // 若無其它需求，可直接使用 AutoMapper 進行資料映照並轉出 return this._mapper.Map\u003cIEnumerable\u003cMainTableDto\u003e\u003e(mainTableList); //============================== // 不使用 AutoMapper 進行資料設定的方式，彈性較高，但是撰寫較麻煩 return mainTableList.Select(o =\u003e new MainTableDto { MainId = o.MainId, // 這邊允許使用 AutoMapper 直接映照欄位，如註解，但若 Sub Table 中只需要特定欄位的話，則建議使用此處範例使用的寫法 // OneToManySubItems = this._mapper.Map\u003cIEnumerable\u003cOneToManySubTableDto\u003e\u003e(o.OneToManySubItems) OneToManySubItems = o.OneToManySubItems.Select(m=\u003enew OneToManySubTableDto { SubId = m.SubId, MainId = m.MainId }), // OneToOneSubItem = this._mapper.Map\u003cOneToOneSubTableDto\u003e(o.OneToOneSubItem) OneToOneSubItem = new OneToOneSubTableDto { SubId = o.OneToOneSubItem.SubId, MainId = o.OneToOneSubItem.MainId }) }).ToListAsync(); } 前述兩種方式的混和寫法，動態調整 Db 出來的欄位，在依據需要組合成輸出用的 Dto 此寫法彈性高，惟程式碼較複雜 cs private async Task\u003cIEnumerable\u003cMainTableDto\u003e\u003e GetAllMainTableDtos() { var mainTableList = await this._testContext.MainTables .AsNoTracking() .Get() .Include(o=\u003eo.OneToManySubItems) .Include(o=\u003eo.OneToOneSubItem) .Select(o=\u003e new MainTable() { MainId = o.MainId, OneToOneSubItem = o.OneToOneSubItem //這邊不再另外設定 OneToMainSubItem 欄位，這樣觸發的 Sql 就會掠過 OneToOneSubItem 這個欄位 }) .ToListAsync(); // 若無其它需求，可直接使用 AutoMapper 進行資料映照並轉出 return this._mapper.Map\u003cIEnumerable\u003cMainTableDto\u003e\u003e(mainTableList); //============================== // 不使用 AutoMapper 進行資料設定的方式，彈性較高，但是撰寫較麻煩 return mainTableList.Select(o =\u003e new MainTableDto { MainId = o.MainId, // 因為前面沒有把 OneToManySubItem 叫出來，這邊就不設定 OneToManySubItem // 若仍保留 OneToManySubItem 欄位的設定，則必須注意 null 值問題 // OneToOneSubItem = this._mapper.Map\u003cOneToOneSubTableDto\u003e(o.OneToOneSubItem) OneToOneSubItem = new OneToOneSubTableDto { SubId = o.OneToOneSubItem.SubId, MainId = o.OneToOneSubItem.MainId }) }).ToListAsync(); } ","date":"2022-02-06","objectID":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/:0:0","series":[],"tags":["EFCore"],"title":"EF Core 自訂關聯","uri":"/2022/02/ef-core-%E8%87%AA%E8%A8%82%E9%97%9C%E8%81%AF/#使用方式"},{"categories":["C#","EF-Core"],"content":"EF Core 中使用 Join","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/"},{"categories":["C#","EF-Core"],"content":"EF Core 中使用 Join 以下操作均使用 EF Core 5.0 以下程式碼範例皆為 EFCore.ToList() 執行前的 IQueryable 操作，也就是仍在組合 SQL 語法的階段 不管使用哪種寫法，皆應盡可能減少巢狀操作 ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:0:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#"},{"categories":["C#","EF-Core"],"content":" Use LinQ Join","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:0:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#use-linq-join"},{"categories":["C#","EF-Core"],"content":" 1 Linq Join 的參考資料 LINQ-to-SQL-Query-Tips-INNER-JOIN-and-LEFT-JOIN) [LINQ+EF]如何做單一條件JOIN以及複合條件JOIN以及多個table的JOIN ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:1:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#linq-join-的參考資料"},{"categories":["C#","EF-Core"],"content":" 2 多欄位匹配 寫法是 Call Method 形式的 Linq，而非參考資料中使用的關鍵字形式的寫法 Key 為多欄位的 Key，對應關係如下 tableA.SectName = tableB.SessionName tableA.DistName = tableB.AreaName cs private IQueryable\u003cOutPutEntity\u003e JointToOutPutEntity( IQueryable\u003cTableA\u003e tableADataList, IQueryable\u003cTableB\u003e tableBDataList) { return tableADataList.Join(tableBDataList, // Join 的第二個參數為 TableA 中要用來處理匹配判斷的欄位 tableA =\u003e new ValueTuple\u003cstring, string\u003e( tableA.SectName, tableA.DistName), // Join 的第三個參數為 TableB 中要用來處理匹配判斷的欄位 tableB =\u003e new ValueTuple\u003cstring, string\u003e( tableB.SessionName, tableB.AreaName), (tableA , tableB) =\u003e new OutPutEntity { LandCode = tableA.LandCode, CurrentValue = tableA.CurrentValue, CurrentPrice = tableA.CurrentPrice, SectName = tableB.SessionId, DistName = tableB.ZipCode, }); } 另一種寫法，如果要將 Join 好的 Table 欄位全數輸出的話可以使用此寫法 cs private IQueryable\u003cOutPutEntity\u003e JointToOutPutEntity( IQueryable\u003cTableA\u003e tableADataList, IQueryable\u003cTableB\u003e tableBDataList) { return tableADataList.Join(tableBDataList, // Join 的第二個參數為 TableA 中要用來處理匹配判斷的欄位 tableA =\u003e new { tableA.SectName, tableA.DistName}, // Join 的第三個參數為 TableB 中要用來處理匹配判斷的欄位 tableB =\u003e new { tableB.SessionName, tableB.AreaName}, (tableA , tableB) =\u003e new { tableA, tableB }); //=====非 Method 寫法如下======= return from tableAData in tableADataList join tableBData in tableBDataList on new { fieldA = tableAData.SectName, fieldB = tableAData.DistName } equals new { fieldA = tableBData.SessionName, fieldB = tableBData.AreaName } select new { tableAData, tableBData }; } ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:2:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#多欄位匹配"},{"categories":["C#","EF-Core"],"content":" 3 單欄位匹配 寫法是 Call Method 形式的 Linq，而非參考資料中使用的關鍵字形式的寫法 Key 為單一欄位的 Key，對應關係如下 tableA.SectName = tableB.SessionName cs private IQueryable\u003cOutPutEntity\u003e JointToOutPutEntity( IQueryable\u003cTableA\u003e tableADataList, IQueryable\u003cTableB\u003e tableBDataList) { return tableADataList.Join(tableBDataList, tableA =\u003e tableA.SectName, tableB =\u003e tableB.SessionName, (tableA , tableB) =\u003e new OutPutEntity { LandCode = tableA.LandCode, CurrentValue = tableA.CurrentValue, CurrentPrice = tableA.CurrentPrice, SectName = tableB.SessionId, DistName = tableB.ZipCode, }); } ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:3:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#單欄位匹配"},{"categories":["C#","EF-Core"],"content":" Select To Object cs private IQueryable\u003cOutPutEntity\u003e JointToOutPutEntity( IQueryable\u003cTableA\u003e tableADataList, IQueryable\u003cTableB\u003e tableBDataList) { return tableADataList.Select(tableAData =\u003e new OutPutEntity() { A = tableAData.SomeField, B = tableBDataList.FirstOrDefault()?.SomeField TableBOneRow = tableBDataList.FirstOrDefault() //TableBOneRow 的型別為 TableB //下面這種寫法會無法使用 //TableBOneRows = tableBDataList //TableBOneRow 的型別為 IEnumerable\u003cTableB\u003e }); } ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:0:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#select-to-object"},{"categories":["C#","EF-Core"],"content":" Use LinQ SelectMany當需要組合多個 Table 時，可使用 SelectMany 來處理。 當使用 SelectMany 後，可以建立極為複雜的可測試查詢 (因為依賴了 IQueryable 與 IEnumerable，而非 SQL)，但是會有一定的開發、維護難度，需要注意。 cs private IQueryable\u003cOutPutEntity\u003e JointToOutPutEntity( IQueryable\u003cTableA\u003e tableADataList, IQueryable\u003cTableB\u003e tableBDataList) { return tableADataList.SelectMany(tableAData =\u003e tableBDataList.Where(tableBData =\u003e tableBData.BId == tableAData.AId) .DefaultIfEmpty(), // 這個設定很重要，會影響 Sql 組成與底下的輸出設定 (tableAData, tablaBData) =\u003e new { tableAData, tableBData }); } ","date":"2022-02-06","objectID":"/2022/02/use-ef-core-to-join/:0:0","series":[],"tags":["EFCore"],"title":"Use EF-Core to Join","uri":"/2022/02/use-ef-core-to-join/#use-linq-selectmany"},{"categories":["Linux"],"content":"Linux Command Memo","date":"2022-02-06","objectID":"/2022/02/linux-command-memo/","series":[],"tags":["Memo"],"title":"Linux Command Memo","uri":"/2022/02/linux-command-memo/"},{"categories":["Linux"],"content":"ssh 遠端到 linux server 時常用的指令筆記 ","date":"2022-02-06","objectID":"/2022/02/linux-command-memo/:0:0","series":[],"tags":["Memo"],"title":"Linux Command Memo","uri":"/2022/02/linux-command-memo/#"},{"categories":["Linux"],"content":" 1 命令紀錄 清空 CLI text ctrl + L 查看路由表 bash netstat -rn 查看網路使用狀態 (Port 使用狀態) bash netstat -lptu netstat -tulpn netstat -tln 刪除路由表 bash route del -net 10.32.0.0/12 清除 IpTables 資料 資料來源：http://s2.naes.tn.edu.tw/~kv/iptables.htm bash ###-----------------------------------------------------### # 清除先前的設定 ###-----------------------------------------------------### # 清除預設表 filter 中，所有規則鏈中的規則 iptables -F # 清除預設表 filter 中，使用者自訂鏈中的規則 iptables -X # 清除mangle表中，所有規則鏈中的規則 iptables -F -t mangle # 清除mangle表中，使用者自訂鏈中的規則 iptables -t mangle -X # 清除nat表中，所有規則鏈中的規則 iptables -F -t nat # 清除nat表中，使用者自訂鏈中的規則 iptables -t nat -X 資料來源：https://kubernetes.io/docs/setup/production-environment/tools/kubeadm/create-cluster-kubeadm/ bash iptables -F \u0026\u0026 iptables -t nat -F \u0026\u0026 iptables -t mangle -F \u0026\u0026 iptables -X 重啟應用程式: bash systemctl restart \u003capplication Name\u003e 確認應用程式執行狀態 bash systemctl status \u003capplication Name\u003e 查看應用程式紀錄 (log) bash journalctl -xeu \u003capplication Name\u003e 設定環境參數 資訊 可以設定到 ~/.bash_profile 檔案內，來讓每次登入都自動套用相關環境參數 bash # 建立環境變數 export \u003ckey\u003e=\u003cvalue\u003e # 使用環境變數 = ${\u003ckey\u003e} 使用範例 bash export test=123 echo ${test} # bash 中會顯示 123 ","date":"2022-02-06","objectID":"/2022/02/linux-command-memo/:1:0","series":[],"tags":["Memo"],"title":"Linux Command Memo","uri":"/2022/02/linux-command-memo/#命令紀錄"},{"categories":["Linux"],"content":" 2 倚賴套件安裝 網路工具 (netstat 需要的套件) bash # yum install net-tools [On CentOS/RHEL] # apt install net-tools [On Debian/Ubuntu] # zypper install net-tools [On OpenSuse] # pacman -S net-tools [On Arch Linux] ","date":"2022-02-06","objectID":"/2022/02/linux-command-memo/:2:0","series":[],"tags":["Memo"],"title":"Linux Command Memo","uri":"/2022/02/linux-command-memo/#倚賴套件安裝"},{"categories":["Kubernetes"],"content":"kube-config 設定參考 警告 這個做法會有安全性問題，理想上還是另外使用管理工具 (如 rancher) 來處理使用者資訊以及一般使用者使用的 kubeconfig ","date":"2022-02-06","objectID":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/:0:0","series":[],"tags":[],"title":"管理 KubeConfig 設定","uri":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/#"},{"categories":["Kubernetes"],"content":" 1 取得 kubeadm 所建立的叢集的管理設定檔 bash cat /etc/kubernetes/admin.conf ","date":"2022-02-06","objectID":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/:1:0","series":[],"tags":[],"title":"管理 KubeConfig 設定","uri":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/#取得-kubeadm-所建立的叢集的管理設定檔"},{"categories":["Kubernetes"],"content":" 2 取得 suse rke2 所產生的管理設定檔 bash cat /etc/rancher/rke2/rke2.yaml ","date":"2022-02-06","objectID":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/:2:0","series":[],"tags":[],"title":"管理 KubeConfig 設定","uri":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/#取得-suse-rke2-所產生的管理設定檔"},{"categories":["Kubernetes"],"content":" 3 設定檔案結構 yaml apiVersion: v1 clusters: - cluster: certificate-authority-data: \u003cfirst-cluster-cert-data\u003e server: https://\u003cfirst-cluster domain\u003e:6443 name: first-cluster - cluster: certificate-authority-data: \u003csecond-cluster-cert-data\u003e server: https://\u003csecond-cluster domain\u003e:6443 name: second-cluster contexts: - context: cluster: first-cluster user: first-cluster-admin name: first-cluster-admin@first-cluster - context: cluster: second-cluster user: second-cluster-admin name: second-cluster-admin@second-cluster current-context: first-cluster-admin@first-cluster kind: Config preferences: {} users: - name: first-cluster-admin user: client-certificate-data: \u003cfirst-cluster-admin-cert-data\u003e client-key-data: \u003cfirst-cluster-admin-cert-key\u003e - name: second-cluster-admin user: client-certificate-data: \u003csecond-cluster-admin-cert-data\u003e client-key-data: \u003csecond-cluster-admin-cert-key\u003e ","date":"2022-02-06","objectID":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/:3:0","series":[],"tags":[],"title":"管理 KubeConfig 設定","uri":"/2022/02/%E7%AE%A1%E7%90%86-kubeconfig-%E8%A8%AD%E5%AE%9A/#設定檔案結構"},{"categories":["Kubernetes"],"content":"Kubernetes","date":"2022-02-06","objectID":"/2022/02/kubernetes-metrics-install/","series":[],"tags":["Metrics","Prometheus-Adapter","Metrics-Server","Install"],"title":"Kubernetes Metrics Install","uri":"/2022/02/kubernetes-metrics-install/"},{"categories":["Kubernetes"],"content":"要讓 Kubernetes 中的 HPA(horizontal-pod-autoscaler) 起作用，就必須安裝負載監測服務，這邊整理了 Metrics-Server 與 Prometheus-Adapter 的安裝方式。 ","date":"2022-02-06","objectID":"/2022/02/kubernetes-metrics-install/:0:0","series":[],"tags":["Metrics","Prometheus-Adapter","Metrics-Server","Install"],"title":"Kubernetes Metrics Install","uri":"/2022/02/kubernetes-metrics-install/#"},{"categories":["Kubernetes"],"content":" Prometheus-Adapter Prometheus Install Use Istioctl addon 在搭配 istio 進行建置的 Kubernetes 的環境下，由於 istio 官方的安裝工具中有提供配合 istio 的 Prometheus 安裝設定，方便起見，可直接使用 istio 提供的安裝設定進行安裝。 若沒有使用 istio，則建議統一使用 Helm 的方式安裝 Prometheus / Prometheus-Adapter。 以下命令的紀錄已預設您目前的 bash 位置位於 istio 官方套件的資料夾中；即 istioctl 的下載資料夾 bash kubectl apply -f samples/addons/prometheus.yaml Use Helm 新增 prometheus 的 helm charts repo bash helm repo add prometheus-community https://prometheus-community.github.io/helm-charts helm repo add stable https://kubernetes-charts.storage.googleapis.com/ helm repo update Install 以下命令會在 monitoring 這個 namespace 中安裝 prometheus bash helm -n monitoring install prometheus prometheus-community/prometheus Prometheus 服務網頁的 istio gateway (選擇性) istio 官方參考資料 資訊 這邊是建立進入 Prometheus 網頁的 istio 相關服務，非必要 bash cat \u003c\u003cEOF | kubectl apply -f - apiVersion: networking.istio.io/v1alpha3 kind: Gateway metadata: name: prometheus-gateway namespace: istio-system spec: selector: istio: ingressgateway servers: - port: number: 80 name: http-prom protocol: HTTP hosts: - \"\u003cyour domain\u003e\" --- apiVersion: networking.istio.io/v1alpha3 kind: VirtualService metadata: name: prometheus-vs namespace: istio-system spec: hosts: - \"prometheus.${INGRESS_DOMAIN}\" gateways: - prometheus-gateway http: - route: - destination: host: prometheus port: number: 9090 --- apiVersion: networking.istio.io/v1alpha3 kind: DestinationRule metadata: name: prometheus namespace: istio-system spec: host: prometheus trafficPolicy: tls: mode: DISABLE --- EOF Prometheus-Adapter Install 準備安裝要用的 Helm Values yaml (named prometheus-adapter-values.yaml) Yaml 原始參考資料 rules 區塊設定內容參考資料 yaml prometheus: # 這邊設定 kubernetes 中 prometheus 服務的位置 # 由於我使用的是 istio 內附的安裝檔，所以連結為 istio 的連結 # url 格式為 http://{kube-service-name}.{namespace}.svc.cluster.{cluster-name} url: http://prometheus.istio-system.svc.cluster.local port: 9090 rules: default: true resource: cpu: containerQuery: sum(rate(container_cpu_usage_seconds_total{\u003c\u003c.LabelMatchers\u003e\u003e, container!=\"\"}[5m])) by (\u003c\u003c.GroupBy\u003e\u003e) nodeQuery: sum(rate(container_cpu_usage_seconds_total{\u003c\u003c.LabelMatchers\u003e\u003e, id='/'}[5m])) by (\u003c\u003c.GroupBy\u003e\u003e) resources: overrides: node: resource: node namespace: resource: namespace pod: resource: pod containerLabel: container memory: containerQuery: sum(container_memory_working_set_bytes{\u003c\u003c.LabelMatchers\u003e\u003e, container!=\"\"}) by (\u003c\u003c.GroupBy\u003e\u003e) nodeQuery: sum(container_memory_working_set_bytes{\u003c\u003c.LabelMatchers\u003e\u003e,id='/'}) by (\u003c\u003c.GroupBy\u003e\u003e) resources: overrides: node: resource: node namespace: resource: namespace pod: resource: pod containerLabel: container window: 5m custom: - seriesQuery: '{__name__=~\"istio_requests_total\"}' seriesFilters: [] resources: overrides: kubernetes_namespace: resource: namespace kubernetes_pod_name: resource: pod destination_service_name: resource: service name: matches: \"^(.*)_total\" as: \"${1}_per_min\" metricsQuery: sum(increase(\u003c\u003c.Series\u003e\u003e{\u003c\u003c.LabelMatchers\u003e\u003e}[1m])) by (\u003c\u003c.GroupBy\u003e\u003e) 使用 helm cli 安裝 警告 我的測試環境是搭配 ArgoCD 設定 Prometheus 的 Helm Repo，並在設定 Application 時進行以下變更 1. 指定使用預設 values 2. prometheus url 是使用 ArgoCD WebUI 去獨立調整，並沒有設定在自訂 Values yaml 中 3. 自訂 Values yaml 的部分僅有 rules: 以下內容 由於不是使用 CLI 作業，我不保證我這邊提供的命令是可用的 bash helm -n istio-system install prometheus-adapter prometheus-community/prometheus-adapter -f prometheus-adapter-values.yaml 等待部屬完畢之後 HPA 中的 unknow 應該就都會變成實際的資源使用量了 helm 安裝時使用的自訂 Yaml 檔案中的 rule 說明 版本 1 參考網址 yaml rules: custom: - seriesQuery: 'istio_requests_total{kubernetes_namespace!=\"\",kubernetes_pod_name!=\"\"}' resources: overrides: kubernetes_namespace: {resource: \"namespace\"} kubernetes_pod_name: {resource: \"pod\"} name: matches: \"^(.*)_total\" as: \"${1}_per_second\" metricsQuery: 'sum(rate(\u003c\u003c.Series\u003e\u003e{\u003c\u003c.LabelMatchers\u003e\u003e}[2m])) by (\u003c\u003c.GroupBy\u003e\u003e)' 版本 2 參考網址 yaml rules: custom: - seriesQuery: '{__name__=~\"istio_requests_total\"}' seriesFilters: [] resources: overrides: kubernetes_namespace: resource: namespace kubernetes_pod_name: resource: pod destination_service_name: resource: service name: matches: \"^(.*)_total\" as: \"${1","date":"2022-02-06","objectID":"/2022/02/kubernetes-metrics-install/:0:0","series":[],"tags":["Metrics","Prometheus-Adapter","Metrics-Server","Install"],"title":"Kubernetes Metrics Install","uri":"/2022/02/kubernetes-metrics-install/#prometheus-adapter"},{"categories":["Kubernetes"],"content":" 1 Use Metrics-ServerMetrics-server 官方 GitHub 前置作業 - TLS Issue metrics-server use https k8s 啟用證書管理 metrics-server github faq Edit Kubelet Config 使用命令確認 kubelet-config 的名稱 text kubectl get cm -n kube-system 執行後應該可以看到 kubelet-config-\u003cversion\u003e 的設定名稱 編輯 kubelet-config text kubectl edit cm kubelet-config-\u003cversion\u003e -n kube-system 在 data 區段最下方加入這行 (或確認這行有沒有存在) text serverTLSBootstrap: true 執行 :wq 存檔 調整每個 Node 中的 kubelet 設定檔 編輯設定檔 text vim /var/lib/kubelet/config.yaml 在 data 區段最下方加入這行 (或確認這行有沒有存在) text serverTLSBootstrap: true 執行 :wq 存檔 Restart kubelet (每個 NODE (Master/sub) 都要執行) text systemctl restart kubelet 使用命令確認憑證狀態 text kubectl get csr 批准前一步取得的憑證清單中，尚未認證的項目 text kubectl certificate approve \u003cCSR-名稱\u003e 補充-列出現有憑證 text kubeadm certs check-expiration 補充-更新憑證 text kubeadm certs renew 補充-自動更新 kubelet 憑證的工具 kubelet rubber stamp 資訊 kubeadm 安裝時預設有設定自動更新憑證，但不確定是否可自動更新 kubelet 的憑證，待確認 Use Helm Install Add Metrics-Server Helm Repo bash helm repo add metrics-server https://kubernetes-sigs.github.io/metrics-server/ Install 若未給 namespace 參數，會被安裝在 default 之中，建議安裝到 Kube-system bash helm upgrade --install metrics-server metrics-server/metrics-server -n kube-system Edit metrics-server deploy setting command text kubectl edit deploy -n kube-system metrics-server 調整內容 metrics-server depoly 設定參考 yaml spec: containers: - args: - --kubelet-preferred-address-types=InternalIP,ExternalIP,Hostname #下面這行如果沒有處理前置步驟那邊的證書設定的話會需要 #- --kubelet-insecure-tls - --metric-resolution=30s image: k8s.gcr.io/metrics-server-amd64:v0.3.3 imagePullPolicy: Always name: metrics-server resources: {} terminationMessagePath: /dev/termination-log terminationMessagePolicy: File volumeMounts: - mountPath: /tmp name: tmp-dir dnsPolicy: ClusterFirst #下面這行很重要 hostNetwork: true Proxy 問題 如果更新完前述內容遲遲無法看到 HPA 顯示資源使用狀況的話，需檢視 Proxy 設定 建議 NO_PROXY 要設定這些 Linux 設定 NO_PROXY bash export NO_PROXY=istio-sidecar-injector.istio-system.svc,.svc,172.30.0.0/16,localhost,10.0.0.0/8 kube.apiserver 設定 NO_PROXY bash vim /etc/kubernetes/manifests/kube-apiserver.yaml 編輯 env: 區段 yaml env: - name: HTTPS_PROXY value: \u003cProxy Server\u003e - name: NO_PROXY value: istio-sidecar-injector.istio-system.svc,.svc,localhost,10.0.0.0/8 ","date":"2022-02-06","objectID":"/2022/02/kubernetes-metrics-install/:1:0","series":[],"tags":["Metrics","Prometheus-Adapter","Metrics-Server","Install"],"title":"Kubernetes Metrics Install","uri":"/2022/02/kubernetes-metrics-install/#use-metrics-server"},{"categories":["Kubernetes"],"content":" 2 REF github devopsbox-io/example-istio-hpa k8s安装metrics-server deckhouse.io/prometheus-metrics-adapter ","date":"2022-02-06","objectID":"/2022/02/kubernetes-metrics-install/:2:0","series":[],"tags":["Metrics","Prometheus-Adapter","Metrics-Server","Install"],"title":"Kubernetes Metrics Install","uri":"/2022/02/kubernetes-metrics-install/#ref"},{"categories":["Istio"],"content":"使用 Helm 安裝 Istio ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-helm/:0:0","series":[],"tags":["Istio","service-mesh"],"title":"Istio Install - Use Helm","uri":"/2022/02/istio-install-use-helm/#"},{"categories":["Istio"],"content":" 官方參考資料 用官方工具安裝 : https://istio.io/latest/docs/setup/install/istioctl/ 用 HELM 安裝 : https://istio.io/latest/docs/setup/install/helm/ ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-helm/:0:0","series":[],"tags":["Istio","service-mesh"],"title":"Istio Install - Use Helm","uri":"/2022/02/istio-install-use-helm/#官方參考資料"},{"categories":["Istio"],"content":" Use HELM 警告 2022-01-10 OS: CentOS 7 - Kernel: 3.10 Helm 中的 istio gateway 版本安裝再 kernel = 3.10 的 linux 上面會發生以下問題，建議使用 istioctl 工具安裝 container init caused “open /proc/sys/net/ipv4/ip_unprivileged_port_start: no such file or directory” 更新 HELM 資料 bash helm repo add istio https://istio-release.storage.googleapis.com/charts helm repo update 建立 istio namespace bash kubectl create namespace istio-system 安裝核心 bash helm install istio-base istio/base -n istio-system 安裝 istio discovery chart bash helm install istiod istio/istiod -n istio-system --wait 安裝 Istio Ingress Gateway (做為主要的系統進入點，替代 k8s ingress gateway) bash kubectl create namespace istio-ingress kubectl label namespace istio-ingress istio-injection=enabled helm install istio-ingress istio/gateway -n istio-ingress --wait 資訊 如果在安裝 Istio Ingress Gateway 出現下列訊息 Error: INSTALLATION FAILED: timed out waiting for the condition 請移除 namespace istio-ingress 上面的 istio-injection=enabled label 後再重新執行以下命令 bash kubectl create namespace istio-ingress helm install istio-ingress istio/gateway -n istio-ingress --wait ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-helm/:0:0","series":[],"tags":["Istio","service-mesh"],"title":"Istio Install - Use Helm","uri":"/2022/02/istio-install-use-helm/#use-helm"},{"categories":["Istio"],"content":" Set SiteCar bash kubectl label namespace default istio-injection=enabled --overwrite kubectl get namespace -L istio-injection 警告 如果車掛不上去，或是掛上去之後發現無法部屬，請檢查 kube-apiserver 這個 pod 的環境變數 當 api server 有掛 proxy 的話，會無法掛車 REF (SCH): https://istio.io/latest/zh/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-Kubernetes-API-server-has-proxy-settings REF (ENG): https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings 有兩種解法 (建議方法 2) ： 重啟方式的參考 : https://stackoverflow.com/a/51763158 調整環境變數並重啟 (刪除) pods/kube-apiserver，讓 apiserver 套用設定 設定環境變數 bash export NO_PROXY=NO_PROXY=istio-sidecar-injector.istio-system.svc,.svc 刪除 kube-apiserver (因為 api server 是由 k8s 系統管理，刪除後會自動重建) bash kubectl delete po kube-apiserver-\u003cnode name\u003e -n kube-system 如果有定義開機 (登入) 後自動建立 PROXY 的環境變數，將 NO_PROXY 設定加入 bash vim ~/.bash_profile # 把 NO_PROXY 設定檔加到環境變數 export NO_PROXY=NO_PROXY=istio-sidecar-injector.istio-system.svc,.svc source ~/.bash_profile 編輯 api server 的設定檔後重啟 開啟設定檔 text vim /etc/kubernetes/manifests/kube-apiserver.yaml 找到 env 節點並加入 NO_PROXY 設定 yaml env: - name: HTTPS_PROXY value: \u003cyour proxy\u003e - name: NO_PROXY value: istio-sidecar-injector.istio-system.svc,.svc 刪除 kube-apiserver (因為 api server 是由 k8s 系統管理，刪除後會自動重建) text kubectl delete po kube-apiserver-\u003cnode name\u003e -n kube-system ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-helm/:0:0","series":[],"tags":["Istio","service-mesh"],"title":"Istio Install - Use Helm","uri":"/2022/02/istio-install-use-helm/#set-sitecar"},{"categories":["Istio"],"content":" 解除安裝 Istio bash helm install istio-base istio/base -n istio-system helm install istiod istio/istiod -n istio-system --wait kubectl delete namespace istio-system ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-helm/:0:0","series":[],"tags":["Istio","service-mesh"],"title":"Istio Install - Use Helm","uri":"/2022/02/istio-install-use-helm/#解除安裝-istio"},{"categories":["Istio"],"content":"Istio 安裝筆記","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/"},{"categories":["Istio"],"content":"使用 Istio 官方 CLI (istioctl) 安裝 Istio ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#"},{"categories":["Istio"],"content":" 官方參考資料 用官方工具安裝 : https://istio.io/latest/docs/setup/install/istioctl/ 用 HELM 安裝 : https://istio.io/latest/docs/setup/install/helm/ ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#官方參考資料"},{"categories":["Istio"],"content":" Use istioctldownload bash # Latest curl -L https://istio.io/downloadIstio | sh - # specific version curl -L https://istio.io/downloadIstio | ISTIO_VERSION=1.12.0 TARGET_ARCH=x86_64 sh - 記得到參數檔案內設定 istioctl 的執行檔位置 bash vim ~/.bash_profile # 把 istio 工具加入執行路徑 PATH=$PATH:$HOME/bin:/root/istio-1.12.0/bin #PATH=$PATH:$HOME/bin:/root/istio-1.12.1/bin 如果是在 Single Node Cluster 的環境下，記得下這個指令才能在 Master (Control plane) 安裝服務 資訊 istio 除了 core 之外都是屬於一般服務，如果沒有下 taint 的指令會無法安裝成功 bash kubectl taint nodes --all node-role.kubernetes.io/master- # kubernetes 1.24 要改用這個 kubectl taint nodes --all node-role.kubernetes.io/control-plane- node-role.kubernetes.io/master- 在正式環境上，建議最小安裝，後續其他東西慢慢個別裝 bash istioctl install --set profile=minimal 警告 istio cni 只是 k8s cni 的擴充套件，仍需要安裝 weave net cni 等 cni 服務 官方安裝資料 使用最小 + istio cni bash istioctl install --set profile=minimal --set components.cni.enabled=true 資訊 建議使用最小 + CNI Ingress / Egress Gateway 都可以之後再依據實際的網路需求安裝 (例如要控制對外開放的 port 之類的) 只是要注意，Ingress / Egress Gateway 的自訂安裝需要在同一個檔案，不能個別製作檔案再用 istioctl 工具安裝，因為不存在於當次安裝使用的 yaml 檔中的 gateway 設定會被 istioctl 工具清掉 使用 default + istio cni bash istioctl install --set components.cni.enabled=true –取得 istio ingress gateway 的狀態 (使用官方提供的預設安裝檔時可用) bash kubectl get svc istio-ingressgateway -n istio-system –查 k8s ingress 設定狀況 bash kubectl get ingress --all-namespaces –查 k8s gateway 設定狀況 bash kubectl get gateway --all-namespaces ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#use-istioctl"},{"categories":["Istio"],"content":" Set SiteCar bash kubectl label namespace default istio-injection=enabled --overwrite kubectl get namespace -L istio-injection 警告 如果車掛不上去，或是掛上去之後發現無法部屬，請檢查 kube-apiserver 這個 pod 的環境變數 當 api server 有掛 proxy 的話，會無法掛車 REF (SCH): https://istio.io/latest/zh/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-Kubernetes-API-server-has-proxy-settings REF (ENG): https://istio.io/latest/docs/ops/common-problems/injection/#automatic-sidecar-injection-fails-if-the-kubernetes-api-server-has-proxy-settings 有兩種解法 (建議方法 2) ： 重啟方式的參考 : https://stackoverflow.com/a/51763158 調整環境變數並重啟 (刪除) pods/kube-apiserver，讓 apiserver 套用設定 設定環境變數 bash export NO_PROXY=NO_PROXY=istio-sidecar-injector.istio-system.svc,.svc 刪除 kube-apiserver (因為 api server 是由 k8s 系統管理，刪除後會自動重建) bash kubectl delete po kube-apiserver-\u003cnode name\u003e -n kube-system 如果有定義開機 (登入) 後自動建立 PROXY 的環境變數，將 NO_PROXY 設定加入 bash vim ~/.bash_profile # 把 NO_PROXY 設定檔加到環境變數 export NO_PROXY=NO_PROXY=istio-sidecar-injector.istio-system.svc,.svc source ~/.bash_profile 編輯 api server 的設定檔後重啟 開啟設定檔 text vim /etc/kubernetes/manifests/kube-apiserver.yaml 找到 env 節點並加入 NO_PROXY 設定 yaml env: - name: HTTPS_PROXY value: \u003cyour proxy\u003e - name: NO_PROXY value: istio-sidecar-injector.istio-system.svc,.svc 刪除 kube-apiserver (因為 api server 是由 k8s 系統管理，刪除後會自動重建) text kubectl delete po kube-apiserver-\u003cnode name\u003e -n kube-system ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#set-sitecar"},{"categories":["Istio"],"content":" 解除安裝 Istio bash istioctl x uninstall --purge istioctl x uninstall --set profile=minimal --purge kubectl delete namespace istio-system ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#解除安裝-istio"},{"categories":["Istio"],"content":" 驗證 Instio 安裝 bash istioctl manifest generate \u003e $HOME/generated-manifest.yaml istioctl manifest generate --set profile=minimal \u003e $HOME/generated-manifest.yaml istioctl verify-install -f $HOME/generated-manifest.yaml ","date":"2022-02-01","objectID":"/2022/02/istio-install-use-istioctl/:0:0","series":[],"tags":["Istio","service-mesh","Install"],"title":"Istio Install - Use istioctl","uri":"/2022/02/istio-install-use-istioctl/#驗證-instio-安裝"},{"categories":["Kubernetes"],"content":"Kubectl command note","date":"2022-02-01","objectID":"/2022/02/kubectl-command-note/","series":["Kubernetes"],"tags":["Kubernetes"],"title":"Kubectl command note","uri":"/2022/02/kubectl-command-note/"},{"categories":["Kubernetes"],"content":"Kubernetes CLI - Kubectl 的命令表 kubectl 是 k8s 核心的工具，每個 node 都會需要裝一個 這邊整理出常用命令，詳細命令請參考官方網站 資訊 這邊列出一些常用的完整命令或是一些範例，若有其他需求可以配合常用參數表進行組合 有些命令上有應用情境，在這邊就不會附上範例 (例如 kubectl apply / kubectl delete) 取得現在使用的設定檔 text kubectl config current-context 常用參數表 參數 說明 -n \u003cnamespace\u003e 定義現在的命令是對應特定 namespace，取 nodes 資料時無效果 –all-namespaces 定義現在的命令是對應所有 namespace，取 nodes 資料時無效果，在有指定特定資源時會報錯 -A 定義現在的命令是對應所有 namespace，取 nodes 資料時無效果，在有指定特定資源時會報錯 -o wide 呈現更多資料，kubectl describe * 命令無法使用 po \u003cpods name\u003e 代表 pods，沒有設定指定 pods name 的話代表所有 pods pos \u003cpods name\u003e 同 po \u003cpods name\u003e pods \u003cpods name\u003e 同 po \u003cpods name\u003e no \u003cNodes name\u003e 代表 nodes，沒有設定指定 nodes name 的話代表所有 nodes 或是執行命令的本機 (看執行 get 還是 describe 命令) node \u003cNodes name\u003e 同 no \u003cNodes name\u003e nodes \u003cNodes name\u003e 同 no \u003cNodes name\u003e svc \u003cservice name\u003e 代表 service，沒有設定指定 service name 的話代表所有 service service \u003cservice name\u003e 同 svc \u003cservice name\u003e services \u003cservice name\u003e 同 svc \u003cservice name\u003e all 取得可以取得的所有資源 ( pods / nodes / service / …) ns namespace 配合 get / describe 命令，可以指定要取得哪個 namespace 的資料，沒有定義名字的話代表全部，與 -n 效果不同 kubectl describe * 取得指定項目的詳細內容 可以用來看檔案 (或網路資源) 內容 警告 -o wide 參數無效 不建議使用 all \u0026 -A 參數 指定 pods 詳細內容 bash kubectl describe pods \u003cpods name\u003e -n \u003cnamespace\u003e Node 詳細內容 因為 node 沒有 namespace 問題，所以 namespace 相關參數在看 node 時無效 (但不會報錯) 沒有定義 node 名稱時，預設執行命令的那台機器 bash kubectl describe no \u003cpods name\u003e 所有可取得的資料的詳細內容 (預設命名空間) bash kubectl describe all 所有可取得的資料的詳細內容 (所有命名空間) bash kubectl describe all -A kubectl get * 取得指定項目的資訊清單，這個命令的資料主要表現形式為表格 取得特定 namespace 的所有資訊 bash kubectl get all -n \u003cname space\u003e 取得所有 K8s 資料的表格 bash kubectl get all -A 取得 kube-system 這個 namespace 中的所有 pods 並列出更詳細的內容 bash kubectl get po -n kube-system -o wide kubectl get pods -n kube-system -o wide 列出所有 pods (不限命名空間) bash kubectl get pods --all-namespaces kubectl get pods -A 取得所有服務 bash kubectl get svc -A kubectl get services -A 取得部屬清單 bash kubectl get deployment -A kubectl apply -f \u003cfile or url\u003e 套用部屬設定並進行部屬 kubectl delete -f \u003cfile or url\u003e 刪除部屬設定與已部屬資源 kubectl port-forward \u003cpods name\u003e \u003chost port\u003e:\u003cpods port\u003e -n \u003cnamespace\u003e 定義 pode 對外的 port 警告 不建議使用 kubectl rollout restart deploy -n \u003cNAMESPACE\u003e 重啟已部屬資源 資訊 所有命名空間的參數 -A 在這個命令無效 REF1: https://qvault.io/open-source/how-to-restart-all-pods-in-a-kubernetes-namespace/ REF2: https://discuss.kubernetes.io/t/restart-all-deployment-in-a-namespace/8165/7 重啟指定命名空間內的資源 bash kubectl rollout restart deploy -n \u003cNAMESPACE\u003e 指定部屬資料進行重啟 資訊 部屬設定的名稱可配合 kubectl get deploymant 命令取得 bash kubectl rollout restart deployments/\u003cname\u003e ","date":"2022-02-01","objectID":"/2022/02/kubectl-command-note/:0:0","series":["Kubernetes"],"tags":["Kubernetes"],"title":"Kubectl command note","uri":"/2022/02/kubectl-command-note/#"},{"categories":["Kubernetes"],"content":"Kubernetes Overloading","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/"},{"categories":["Kubernetes"],"content":"Kubernetes Node 的負載相關筆記 ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#"},{"categories":["Kubernetes"],"content":" 資源設定單位[Kubernetes] 分配 \u0026 管理 container 所使用到的計算資源 ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#資源設定單位"},{"categories":["Kubernetes"],"content":" 1 CPUKubernetes officiel Document CPU 資源設定在沒有附帶單位的狀況下，該數字視為 CPU Core 數量；例如 1 = 1 core。 單位 1000m = 1 (core) 最小為 100m (= 0.1 core) 如果資源設定要小於 1 core 的話，建議使用 100~1000m 的數值來設定，雖然支援小數點設定 (0.5 = 500m)，但是建議讓設定格式一致，減少小數點的出現次數。 ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:1:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#cpu"},{"categories":["Kubernetes"],"content":" 2 Memory 資訊 目前常見的資源設定單位都會帶有 i 後綴的版本，例如 Mi (Mebibyte)，因為相比 MB 來說，MiB 的定義更為明確；MB 的定義混亂，有時被看作 1024 KB，有時又是 1000 KB。 Kubernetes officiel Document Mi = Mebibyte wiki 1 MiB = 2^20 bytes = 1024 kibibytes = 1048576bytes M = Megabyte wiki ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:2:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#memory"},{"categories":["Kubernetes"],"content":" 基礎能力負載HPA 設定參照 ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#基礎能力負載"},{"categories":["Kubernetes"],"content":" 1 在要用於測試的 node 上加入標籤為了避免在測試時影響到運行中的服務，可以在 node 上面加上標籤，來限制壓測時要使用的 node 警告 2022-01-04 此節僅做筆記，尚未進行實機測試 設定 Label 的命令 bash kubectl label node \u003cnode-name\u003e \u003clabel\u003e=\u003cvalue\u003e --overwrite 列出有 node-role.kubernetes.io/worker=ci 這個 label 的命令 bash kubectl top node -l node-role.kubernetes.io/worker=ci ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:1:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#在要用於測試的-node-上加入標籤"},{"categories":["Kubernetes"],"content":" 2 Kubernetes 官網紀錄的資源限制依據 官網文件 紀錄，Kubernetes v1.23 中的資源負載數量如下： 1 Node 最多 110 Pods 備註：代表一個 Node 中，kubelet 工具可以操作的 pod 數量 1 Cluster 最多 5000 Nodes 1 Cluster 中總計最多 150,000 個 Pods 1 Cluster 中總計最多 300,000 個 Docker Containers ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:2:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#kubernetes-官網紀錄的資源限制"},{"categories":["Kubernetes"],"content":" Istio 網格能力負載","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#istio-網格能力負載"},{"categories":["Kubernetes"],"content":" 1 Istio Sidecar 資源限制使用 kubectl describe pod 命令查閱 pod，可以在 istio-proxy: 區段發現，Istio 所初始化的 Sidecar Container 所給予的資源為 text Limits: cpu: 2 memory: 1Gi Requests: cpu: 100m memory: 128Mi ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:1:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#istio-sidecar-資源限制"},{"categories":["Kubernetes"],"content":" 2 搭配 Istio 的其他影響 資訊 以下影響以預設安裝不調整參數的 Istio 為主 因為 Sidecar 的增加，每一層 Sidecar 容器會微幅增加約 0.5ms 的延遲 使用默认istio-proxy的资源配置下, 最多可以抗住 1w 左右的HTTP请求并发. 此項直接引述參考文件中 isito envoy sidecar的全面性能压力测试 的結論內容未做修正的原因是，文內的 1w 代表數量未知 ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:2:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#搭配-istio-的其他影響"},{"categories":["Kubernetes"],"content":" Horizontal Pod Autoscaler (HPA)HPA 可以監測負載狀況，實現自動拓展 pod 來增加系統負載能力 倚賴 metrics server ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#horizontal-pod-autoscaler-hpa"},{"categories":["Kubernetes"],"content":" 壓力測試工具 警告 2022-01-04 此節僅做筆記，尚未進行實機測試 https://www.dotblogs.com.tw/armycoding/2021/12/02/k6-introuction ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#壓力測試工具"},{"categories":["Kubernetes"],"content":" 1 Docker-BusyBoxBusyBox 啟動測試容器 bash kubectl run --generator=run-pod/v1 -i --tty load-generator --image=busybox /bin/sh ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:1:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#docker-busybox"},{"categories":["Kubernetes"],"content":" 2 官方的測試工具？kubernetes perf-tests ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:2:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#官方的測試工具"},{"categories":["Kubernetes"],"content":" 3 可能可以用的工具 https://github.com/wg/wrk https://github.com/giltene/wrk2 https://github.com/rakyll/hey https://github.com/tsenart/vegeta ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:3:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#可能可以用的工具"},{"categories":["Kubernetes"],"content":" 參考資料 認識負載測試與 k6 Kubernetes 動態建立 Jenkins Agent 壓力測試 (繁中翻譯版) Kubernetes 動態建立 Jenkins Agent 壓力測試 (原始來源) isito envoy sidecar的全面性能压力测试 Kubernetes系列之Kubernetes的弹性伸缩（HPA） ","date":"2022-02-01","objectID":"/2022/02/kubernetes-overloading/:0:0","series":["Kubernetes"],"tags":["Kubernetes","Istio","Overloading"],"title":"Kubernetes Overloading","uri":"/2022/02/kubernetes-overloading/#參考資料"},{"categories":["Development"],"content":"測試驅動開發筆記","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/"},{"categories":["Development"],"content":"測試驅動開發的流程筆記 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#"},{"categories":["Development"],"content":" 測試驅動開發 (Test Driven Development)","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:0:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#測試驅動開發-test-driven-development"},{"categories":["Development"],"content":" 1 首先 TDD is not Test First! Test First 只是 TDD 的一環 TDD 整個流程包含需求分析與測試案例設計 不是有寫單元/整合測試就叫做 TDD 測試只是 TDD 中的其中一部份 文末的參考資料有提供各式建議書籍與相關課程 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:1:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#首先"},{"categories":["Development"],"content":" 2 Test First 的類型此章節為我流理解法，並非正式的方法介紹，若有任何錯誤的地方還請不吝指教！ ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:2:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#test-first-的類型"},{"categories":["Development"],"content":" 2.1 Outside In 各種別稱 Top Down London School Mockist Approach Outside In，由外而內的處理，在開始動工前只會決定想要用什麼方式去完成實作，類別的名稱架構、方法等內容，都是在測試實作時一步一步建立的。 這種做法我認為是需求優先的做法。 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:2:1","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#outside-in"},{"categories":["Development"],"content":" 2.2 Inside Out 各種別稱 Classic school bottom-up Inside Out，由內而外的處理，在開始動工前會先規劃好所有類別的長相，並由最內側開始往外建立測試與調整實作。 這種做法我認為是架構優先的做法。 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:2:2","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#inside-out"},{"categories":["Development"],"content":" 3 TDD 流程TDD 在開發時會使用底下的流程進行開發 確認需求與討論預期使用的處理方法 確認需求內容，並規劃程式中預計使用的處理方案；有沒有需要套用特定設計模式架構、若有數學運算或資料比對，相關作法為和？ 設計測試案例 依據需求規劃測試案例，定義每個案例會需要的輸入參數與輸出結果。 排序測試案例 評估前面建立的測試案例中，那些測試要建立的項目最抽象；定義功能介面與方法簽章的測試優先，再來就是確認下一個要完成的測試要改動的項目最小。 例如： 沒有預算資料_輸入 2021/07/01~2021/07/31_7月預算為 0 定義了輸入 (是一個日期範圍) 定義了輸出 (我要拿到的是一個數字) 定義了資料來源 (預算的 Repository) 有 7月預算為 31_輸入 2021/07/01~2021/07/31_取得31 完成從預算 Repo 取得資料後輸出的功能 有 7月預算為 31_輸入 2021/06/01~2021/06/30_取得0 確認搜尋範圍小於資料範圍時的結果 有 7月預算為 31_輸入 2021/08/01~2021/08/31_取得0 確認搜尋範圍大於資料範圍時的結果 …請報名91的TDD課程以解鎖以下內容… 依據前面定義的測試案例順序進行開發 每次案例都應經過以下階段，除非該測試案例是為了驗證其他事情而額外增加的案例；因為這種案例通常是預設現行實作應該要已經有哪些行為，如果這個行為成立，通常會不符合下列的第一項「測試紅燈」 寫一個測試，測試紅燈 (Write a Test) 新加入的測試案例應該會是要加入一個新的功能實作，該功能實作並未完成，這時候通常都是紅燈 若測試剛建立好就是綠燈，通常是 該測試是為了驗證某個已完成功能是正確的 該測試案例有問題 目前實作意外可符合此測試 完成實作，測試綠燈 (Make it run) 在最小修改下完成綠燈 可以刻意讓測試綠燈；可以故意寫一個值讓測試綠燈，確認測試案例的設計正確 修正前面為了通過測試而有的邏輯錯誤 開始重構 (make it Right) 整理實作程式碼 處理程式壞味道 重構修改後都應跑一次測試確保重構並未影響功能 重構測試 整理單元測試的實作程式碼 處理程式壞味道 功能完成 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:3:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#tdd-流程"},{"categories":["Development"],"content":" 4 自己實務上最常碰到的問題 資料來源過於複雜，在撰寫測試的時候非常不好寫 因為我自己在實務上主要使用 EF Core 操作資料庫，再搭配 UnitOfWork \u0026 Repository\u003cT\u003e 操作每張資料表，當資料表組合較複雜時，會發生測試中需要撰寫非常多的資料設定的狀況。目前還在思考該如何在有複雜的資料組合的情境下順利的完成 TDD 流程。 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:4:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#自己實務上最常碰到的問題"},{"categories":["Development"],"content":" 5 參考資料","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:5:0","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#參考資料"},{"categories":["Development"],"content":" 5.1 91 測試課程 91 針對遺留代碼加入單元測試的藝術 91 TDD 與 持續重構 91 TDD 影音課 ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:5:1","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#91-測試課程"},{"categories":["Development"],"content":" 5.2 書籍 Kent Beck 的測試驅動開發：案例導向的逐步解決之道 Working Effectively with Legacy Code : 管理、修改、重構遺留程式碼的藝術 重構｜改善既有程式的設計, 2/e (繁中平裝版) 重構與模式 (Refactoring to Patterns) ","date":"2022-02-01","objectID":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/:5:2","series":[],"tags":["TDD"],"title":"測試驅動開發筆記","uri":"/2022/02/%E6%B8%AC%E8%A9%A6%E9%A9%85%E5%8B%95%E9%96%8B%E7%99%BC%E7%AD%86%E8%A8%98/#書籍"},{"categories":["Version Control"],"content":"Git GUI Tools Memo","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/"},{"categories":["Version Control"],"content":"此篇筆記過往簡單測試過的一些 git gui 工具，時至今日應已有許多變革，此文僅作參考。 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:0:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#"},{"categories":["Version Control"],"content":" Git 工具 撰寫於 2021 / 08 / 20 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:0:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#git-工具"},{"categories":["Version Control"],"content":" 1 首推此節介紹的工具為建議使用工具，基本使用體驗良好 Git cli (命令列) 完全免費 最直接的 Git 操作方式 需要熟記相關命令 對於擷選要加入的內容這件事情比較麻煩 Fork 收費軟體，已公開報價為 49.99 美元，免費版僅作為評估用，但是並未強制收費，僅會不定時提醒 Donate 操作流暢 方便確認變更內容與發佈 commit ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:1:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#首推"},{"categories":["Version Control"],"content":" 2 次推此節介紹的工具普遍體驗良好，但有部分問題導致評價下降 (會在內容說明) GitKraken 部分免費 免費版無法連線到私人 Git Server / Repository 此點導致此軟體的評價下降至次推，因為這個限制會導致需要付費才可在公司環境使用 非常美觀 操作順暢 SourceTree 完全免費 普遍推薦的軟體 介面美觀 容易閱讀 commit 需要建立他們平台的帳號才能使用 此點導致此軟體的評價下降至次推，因為這個限制會導致為了使用這套軟體而註冊帳號，較為不便 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:2:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#次推"},{"categories":["Version Control"],"content":" 3 依個人習慣可選擇 Visual Studio 內建及其擴充功能 Visual Studio 中對 Git 的操作流程稍差 有許多擴充套件可以擴充對 Git 操作的方便性 安裝過多套件會導致效能低落 有慣用 ReSharper 的人不會想要在 VS 上安裝其他套件讓 VS 更慢 與 TFS 有良好整合性，方便操作 TFS 上的功能 擴充套件 : GitFlow for Visual Studio 在 Visual Studio 內使用 Git Flow 時需要的套件 Visual Studio Code 及其擴充功能 建議套件 : Git Graph、GitLens JetBrains Rider 及其擴充功能 付費工具 操作上需要特別開專案或選擇資料夾後再操作，稍嫌不便 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:3:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#依個人習慣可選擇"},{"categories":["Version Control"],"content":" 4 待使用者提供心得 sublimemerge 付費 (99 鎂) 偏貴，也有說明可免費評估，不確定是不是打算走跟 Fork 相同的套路 操作體驗可能是 Fork / GitKraken 的強大競爭者 (依據官方提供的資訊判斷) GitFiend UI 設計還可以，無操作經驗 Cong 主打指令操作，無按鈕 (未有太多使用經驗) Git Extensions 撰文者不喜歡這套，UI 設計也很弱 GitBlade 基本功能免費，不少常用的功能都是付費的，不如直接使用 Git cli Git GUI 安裝 Git for Windows 時會一同安裝，屬於官方自己的 Windows Desktop 工具，還算堪用 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:4:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#待使用者提供心得"},{"categories":["Version Control"],"content":" 5 最後最後提醒一件事情 不建議使用 TortoiseGit 操作Git 能理解從 SVN 轉換過來的使用者會偏好 TortoiseGit 的操作模式，但是其實 Git 的核心作業模式與 SVN 並不相同，因此不建議使用 TortoiseGit 來操作 Git，這會導致無法享受到 Git 的許多優勢。 ","date":"2021-08-20","objectID":"/2021/08/git-gui-tools-memo/:5:0","series":[],"tags":["git"],"title":"Git GUI Tools Memo","uri":"/2021/08/git-gui-tools-memo/#最後"},{"categories":["Development-Tools"],"content":"Refactor Command in Ide","date":"2021-08-20","objectID":"/2021/08/refactor-command-in-ide/","series":[],"tags":["refactor","IDE-hotkey"],"title":"Refactor Command in Ide","uri":"/2021/08/refactor-command-in-ide/"},{"categories":["Development-Tools"],"content":"IDE 常用重構快捷鍵 ","date":"2021-08-20","objectID":"/2021/08/refactor-command-in-ide/:0:0","series":[],"tags":["refactor","IDE-hotkey"],"title":"Refactor Command in Ide","uri":"/2021/08/refactor-command-in-ide/#"},{"categories":["Development-Tools"],"content":" IDE 中提供的重構方法此文件所使用的 IDE 環境為 Visual Studio 2019 + JetBrains ReSharper JetBrains Rider 若為 Visual Studio 原生可使用的功能會在該功能下註記，但原生功能不一定會跟 ReSharper 所提供的功能有相同的方便性 Tips: ReSharper/Rider 可以用 Ctrl + Shift + R 來叫出重構用選單 此文件僅列出常用的重構命令，而這些常用的重構命令在不同情境下會有不同的效果 將選取的內容抽為方法：Ctrl + R -\u003e Ctrl + M VS 快捷鍵設定名稱：重構-提取方法 (Refactor.ExtractMethod) 將選取的變數、參數重新命名：Ctrl + R -\u003e Ctrl + R VS 快捷鍵設定名稱：重構-重新命名 (Refactor.Rename) 將選取方法拉到新的介面 (目前類別會掛上新的介面)：Ctrl + Shift + R -\u003e X VS 快捷鍵設定名稱：重構-提取介面 (Refactor.ExtractInterface) 提取類別：Ctrl + Shift + R -\u003e E 將目前變數、方法攤回到使用端 (Inline)：Ctrl + R + I 安全刪除變數或參數：Alt + Del 可以快速刪除不使用的變數，在有被使用的變數上不建議使用此命令，因為可能引發引用問題 將方法參數整合為一個類別 在方法宣告上使用 Alt + Enter 後輸入 TranP 可找到 “Transform parameters” 在方法宣告上使用 Ctrl + Shift + R -\u003e 選擇 Transform parameters (或者按 P) ","date":"2021-08-20","objectID":"/2021/08/refactor-command-in-ide/:0:0","series":[],"tags":["refactor","IDE-hotkey"],"title":"Refactor Command in Ide","uri":"/2021/08/refactor-command-in-ide/#ide-中提供的重構方法"},{"categories":["Development-Tools"],"content":"Visual Studio Code 好用的套件","date":"2021-08-20","objectID":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/","series":[],"tags":["extensions","Visual-Studio-Code"],"title":"Visual Studio Code 好用的套件","uri":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/"},{"categories":["Development-Tools"],"content":" Visual Studio Code 建議使用的擴充套件","date":"2021-08-20","objectID":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","Visual-Studio-Code"],"title":"Visual Studio Code 好用的套件","uri":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#visual-studio-code-建議使用的擴充套件"},{"categories":["Development-Tools"],"content":" 1 文字編輯類 Code Spell Checker 單字檢查器 GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:1:0","series":[],"tags":["extensions","Visual-Studio-Code"],"title":"Visual Studio Code 好用的套件","uri":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#文字編輯類"},{"categories":["Development-Tools"],"content":" 2 工具類 Git Graph 在 Visual Studio Code 中查看 Git 線圖 GitHub GitLens — Git supercharged 提供文件的 Git 抬頭顯示器，可以以抬頭顯示器的形式查看文件中的變更紀錄 GitHub REST Client 利用 Visual Studio Code 測試 WebAPI GitHub ERD Editor 利用 Visual Studio Code 繪製資料庫 Table 關聯圖 GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:2:0","series":[],"tags":["extensions","Visual-Studio-Code"],"title":"Visual Studio Code 好用的套件","uri":"/2021/08/visual-studio-code-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#工具類"},{"categories":["Development-Tools"],"content":"Visual Studio 好用的套件","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/"},{"categories":["Development-Tools"],"content":" 推薦安裝 CodeMaid 免費 程式碼排版 GitHub GhostDoc 社群免費版 / 專業付費版 協助處裡各個方法的 Summary 標籤的工具 AceJump 免費 游標移動的輔助工具，可以快速地將游標移動到特定位置 GitHub Roslynator 2022 免費 靜態程式碼分析與修改建議工具，速度相較於 ReSharper 快 GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#推薦安裝"},{"categories":["Development-Tools"],"content":" 推薦學習與安裝 VsVim (推薦) 免費 此套會影響 IDE 操作，建議預先學習後再安裝 若有學習需求可找 小佑 (魏佑嘉-G6994) / 小 Ray (許育瑞-G6993) GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#推薦學習與安裝"},{"categories":["Development-Tools"],"content":" 依據專案需求安裝 SlowCheetah 免費 依據建置設定替換設定檔內容值的工具 (使用後會幫專案安裝相關的 nuget 套件) GitHub EF Core Power Tools 免費 操作 EF Core 的工具 GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#依據專案需求安裝"},{"categories":["Development-Tools"],"content":" 推薦付費購買 ReSharper (推薦) ReSharper 也有套件機制，絕大部分與 Rider 相同，因此可參照 Rider Extensions 訂閱資訊： 訂閱資訊網址：https://www.jetbrains.com/store/#personal?billing=yearly 產品：dotUitimate (ReSharper + Rider \u0026 其它 .net 開發用工具，包含效能分析、反組譯等功能) 首年 149 美金 (4,340 NTD - 2022/04/18 匯率 - 未包含跨國刷卡手續費) 第二年 119 美金 (3,466 NTD - 2022/04/18 匯率 - 未包含跨國刷卡手續費) 第三年以後 89 美金 (2,592 NTD - 2022/04/18 匯率 - 未包含跨國刷卡手續費) JetBrains 的個人訂閱認人不認用途，可放心於各種環境安裝使用 ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:0:0","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#推薦付費購買"},{"categories":["Development-Tools"],"content":" 1 ReSharper 專用套件以下列出 Rider 中沒有的套件 Enhanced Tool Tip 替浮動視窗上色，容易檢視方法簽章 (Rider 已內建相關功能) GitHub ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/:1:0","series":[],"tags":["extensions","Visual-Studio"],"title":"Visual Studio 好用的套件","uri":"/2021/08/visual-studio-%E5%A5%BD%E7%94%A8%E7%9A%84%E5%A5%97%E4%BB%B6/#resharper-專用套件"},{"categories":["Development-Tools"],"content":"Visual Studio 常用快捷鍵","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/","series":[],"tags":["refactor","IDE-hotkey"],"title":"Visual Studio 常用快捷鍵","uri":"/2021/08/visual-studio-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/"},{"categories":["Development-Tools"],"content":" Visual Studio 常用命令因每個人的開發環境設定不盡相同，可能某些快捷鍵行為與此處列出的功能有所差異，後面有附帶相關功能在 VS 快捷鍵設定畫面中的中、英文說明，可再依據自己的操作習慣進行調整即可 列出目前游標位置的變數、類別的可選成員：Ctrl + J VS 快捷鍵設定名稱：編輯.列出成員 (Edit.ListMembers) 重複目前所在行/選取文字：Ctrl + D VS 快捷鍵設定名稱：編輯.複製 (Edit.Duplicate) 若 Ctrl + D 無作用，可嘗試 Ctrl + E -\u003e V 此組快捷鍵 中文版這個設定會有兩個，有機會設定錯誤，預設 Ctrl + E -\u003e V 的那組設定才是 快速選取：Ctrl + W VS 快捷鍵設定名稱：編輯-選擇目前文字 (Edit.SelectCurrentWord) 預設環境下此組快捷鍵應是開啟微軟的說明網頁，會需要自行調整 快速移動到特定型別：Ctrl + T VS 快捷鍵設定名稱：編輯-到型別 (Edit.GotoType) 快速移動到特定方法成員：(預設未綁定快捷鍵) VS 快捷鍵設定名稱：編輯-到成員 (Edit.GotoMember) 快速移動到特定系列 VS 快捷鍵設定名稱：編輯-到** (Edit.Goto**) 執行所有測試： VS 快捷鍵設定名稱：TestExplorer.RunAllTests 執行目前游標所在的測試類別中的所有測試 VS 快捷鍵設定名稱：TestExplorer.RunAllTestsInContext ","date":"2021-08-20","objectID":"/2021/08/visual-studio-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/:0:0","series":[],"tags":["refactor","IDE-hotkey"],"title":"Visual Studio 常用快捷鍵","uri":"/2021/08/visual-studio-%E5%B8%B8%E7%94%A8%E5%BF%AB%E6%8D%B7%E9%8D%B5/#visual-studio-常用命令"},{"categories":null,"content":" 施工中 其實是我不知道這頁怎麼寫比較好 ","date":"0001-01-01","objectID":"/about/:0:0","series":null,"tags":null,"title":"關於我","uri":"/about/#施工中"}]