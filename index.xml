<rss xmlns:atom="http://www.w3.org/2005/Atom" version="2.0"><channel><title>-小佑-（&lt;ゝω·）キラbosh☆</title><link>https://yuchia-wei.github.io/</link><description>（&lt;ゝω·）キラbosh☆</description><generator>Hugo -- gohugo.io</generator><language>zh-TW</language><lastBuildDate>Wed, 16 Jul 2025 11:30:00 +0800</lastBuildDate><atom:link href="https://yuchia-wei.github.io/index.xml" rel="self" type="application/rss+xml"/><item><title>在 dockerfile 內使用 alpine 的 dotnet sdk image 建置 dotnet 服務</title><link>https://yuchia-wei.github.io/2025/07/use-dotnet-sdk-alpine-in-docker-file/</link><pubDate>Wed, 16 Jul 2025 11:30:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2025/07/use-dotnet-sdk-alpine-in-docker-file/</guid><description><![CDATA[<p>在我以前的工作環境中，由於建置機採用地端管理，且有儲存容量等限制，如何利用 docker 的 build cache 來增加儲存空間的利用率成了必須思考的議題。</p>
<p>也因為我在規劃 <strong>包含 opentelemetry auto instrumentation</strong> 的 base image 時，也會需要同時發布多種不同 linux 版本的 image，因此，這邊特別研究了多種不同 linux 發行版的 dotnet build 參數並應用在 dockerfile 之中，來讓一份 dockerfile 可以發布多種不同的成品，並且使用相同的建置階段。</p>
<p>這邊使用的 github repo 為 <a href="https://github.com/YuChia-Wei/otel-dotnet-auto-instrumentation" target="_blank" rel="noopener noreferrer">YuChia-Wei/otel-dotnet-auto-instrumentation</a></p>]]></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 3 : 其他包裝方法</title><link>https://yuchia-wei.github.io/2025/07/aspnetcore-webapi-custom-response-model-part3-wrapping-api-response-the-other-way/</link><pubDate>Wed, 16 Jul 2025 11:22:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2025/07/aspnetcore-webapi-custom-response-model-part3-wrapping-api-response-the-other-way/</guid><description><![CDATA[<p>先前在撰寫 wrapping response action filter 的時候其實有利用 ChatGPT 進行輔助，在與 ChatGPT 對話的過程中也有討論到使用 Middleware 處理回應包裝的部分，我想利用這一篇記錄一下當時的對話內容以及結論。
</br>
</br>
因此，本文大部分內容都是由 AI 產出，我再進行整理與調整。
</br>
</br>
<div class="details admonition warning open">
    <div class="details-summary admonition-title">
        <span class="icon"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 576 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M569.517 440.013C587.975 472.007 564.806 512 527.94 512H48.054c-36.937 0-59.999-40.055-41.577-71.987L246.423 23.985c18.467-32.009 64.72-31.951 83.154 0l239.94 416.028zM288 354c-25.405 0-46 20.595-46 46s20.595 46 46 46 46-20.595 46-46-20.595-46-46-46zm-43.673-165.346l7.418 136c.347 6.364 5.609 11.346 11.982 11.346h48.546c6.373 0 11.635-4.982 11.982-11.346l7.418-136c.375-6.874-5.098-12.654-11.982-12.654h-63.383c-6.884 0-12.356 5.78-11.981 12.654z"/></svg></span>警告<span class="details-icon"><svg class="icon"
    xmlns="http://www.w3.org/2000/svg" viewBox="0 0 256 512"><!-- Font Awesome Free 5.15.4 by @fontawesome - https://fontawesome.com License - https://fontawesome.com/license/free (Icons: CC BY 4.0, Fonts: SIL OFL 1.1, Code: MIT License) --><path d="M224.3 273l-136 136c-9.4 9.4-24.6 9.4-33.9 0l-22.6-22.6c-9.4-9.4-9.4-24.6 0-33.9l96.4-96.4-96.4-96.4c-9.4-9.4-9.4-24.6 0-33.9L54.3 103c9.4-9.4 24.6-9.4 33.9 0l136 136c9.5 9.4 9.5 24.6.1 34z"/></svg></span>
    </div>
    <div class="details-content">
        <div class="admonition-content">本文中所使用的方式我並沒有在正式環境中使用，僅是因為在先前與 ChatGPT 討論的過程中有針對這種做法進行討論，然後覺得這段適合保留下來而有這一篇文章。</div></div></div></p>]]></description></item><item><title>2024 年度回顧</title><link>https://yuchia-wei.github.io/2024/12/2024-yearly-retrospective/</link><pubDate>Tue, 31 Dec 2024 22:55:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2024/12/2024-yearly-retrospective/</guid><description>&lt;p>今天是 2024 年的最後一天，雖然不多，但還是小小的回顧一下。&lt;/p></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 2 : 包裝例外</title><link>https://yuchia-wei.github.io/2024/11/aspnetcore-webapi-custom-response-model-part2-wrapping-exception/</link><pubDate>Sun, 17 Nov 2024 11:30:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2024/11/aspnetcore-webapi-custom-response-model-part2-wrapping-exception/</guid><description><![CDATA[<p>這篇為 「幫 AspNetCore WebApi 包上自己的 response model」 的第二部分 「包裝例外」。
</br></p>
<p>我將介紹如何在 ASP.NET Core Web API 中統一處理例外狀況，並將其包裝成標準化的回應格式。</p>
<p>我會介紹以下兩種例外資料的包裝方法：</p>
<ol>
<li>使用 UseExceptionHandler Middleware</li>
<li>使用 IExceptionFilter 介面</li>
</ol>]]></description></item><item><title>幫 AspNetCore WebApi 包上自己的 response model，Part 1 : 包裝 api 回應</title><link>https://yuchia-wei.github.io/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/</link><pubDate>Sat, 12 Oct 2024 00:00:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2024/10/aspnetcore-webapi-custom-response-model-part1-wrapping-api-response/</guid><description><![CDATA[<p>在設計 web api 時，通常會想要有一個自己系統專用的標準化回應格式，我在前一份工作中因為已經有底層的前輩建立好相關的處理套件，所以一直以來都沒特別研究怎麼包裝以及自訂回應欄位。
</br>
</br>
最近在自己的練習專案中嘗試去實作相關機制，才發現原來要考慮的東西有點多，這邊我就來分享一下我的做法以及其他可以用的方式與用途。
</br>
</br></p>]]></description></item><item><title>該使用 SDK 還是 WebApi 的形式提供服務?</title><link>https://yuchia-wei.github.io/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/</link><pubDate>Sun, 03 Mar 2024 22:32:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2024/03/%E8%A9%B2%E4%BD%BF%E7%94%A8-sdk-%E9%82%84%E6%98%AF-webapi-%E7%9A%84%E5%BD%A2%E5%BC%8F%E6%8F%90%E4%BE%9B%E6%9C%8D%E5%8B%99/</guid><description><![CDATA[<p>大家在使用 dotnet 或其他可以打包成功開套件做分享的程式語言時，可能都會想到一個問題</p>
<blockquote>
  <ol>
<li>現在 WebApi 那麼盛行，我該如何抉擇要使用 Web Api 還是 套件 的形式發布我的服務、功能呢？</li>
<li>我覺得我新寫的功能好棒棒，我想發布成 nuget package 分享給團隊，但是不確定合不合適</li>
</ol>
</blockquote><p>這邊我簡單梳理一下一些需要考量的點~</p>]]></description></item><item><title>建立 RKE2 叢集並且安裝 Rancher / istio</title><link>https://yuchia-wei.github.io/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/</link><pubDate>Sun, 28 Jan 2024 21:22:29 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2024/01/%E5%BB%BA%E7%AB%8B-rke2-%E5%8F%A2%E9%9B%86%E4%B8%A6%E4%B8%94%E5%AE%89%E8%A3%9D-rancher-/-istio/</guid><description><![CDATA[<p>我初期在公司建立地端 Kubernetes 叢集以進行 POC 時，都是使用 kubeadm 這套官方工具進行的 (我早期文章就是基於此撰寫的)。</p>
<p>但是當需要將 Kubernetes 拓展到其他單位時，那相對複雜的安裝與管理方式卻是第一個難以躍過的門檻。</p>
<p>因此，後續改用 RKE2 建立，並且導入 Rancher 進行 Kubernetes 叢集管理。從 2022 年末使用至今，由於我們公司的運用情境相對簡單，因此沒出現太多難以處理的問題。</p>
<p>這篇紀錄我的 RKE2 + Rancher 的安裝命令，主要內容都是依據 iThome Kubernetes Summit 2022 時我參與的 SUSE 工作坊講師提供的資訊進行調整，並適度的加上一些說明。</p>]]></description></item><item><title>2023 年度回顧</title><link>https://yuchia-wei.github.io/2023/12/2023-yearly-retrospective/</link><pubDate>Sun, 31 Dec 2023 15:36:28 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2023/12/2023-yearly-retrospective/</guid><description>&lt;p>今天是 2023 年的最後一天，趁著今年還沒結束，來回顧一下我在今年的技術發展狀況吧~&lt;/p>
&lt;p>不過，因為這一年都沒怎麼寫 blog (都靠 hackmd 紀錄筆記)，希望不要不小心把去年的事情寫成今年 XD&lt;/p></description></item><item><title>JetBrains Rider 常用擴充套件</title><link>https://yuchia-wei.github.io/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/</link><pubDate>Sun, 17 Dec 2023 14:40:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2023/12/jetbrains-rider-%E5%B8%B8%E7%94%A8%E6%93%B4%E5%85%85%E5%A5%97%E4%BB%B6/</guid><description>JetBrains Rider 常用擴充套件</description></item><item><title>程式碼重構 - 基本概念</title><link>https://yuchia-wei.github.io/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</link><pubDate>Sun, 17 Dec 2023 14:40:00 +0800</pubDate><author><name>作者</name></author><guid>https://yuchia-wei.github.io/2023/12/%E7%A8%8B%E5%BC%8F%E7%A2%BC%E9%87%8D%E6%A7%8B-%E5%9F%BA%E6%9C%AC%E6%A6%82%E5%BF%B5/</guid><description><![CDATA[<p>重構：在不影響程式碼邏輯的前提下進行程式碼修改的行為</p>
<p>重構行為應使用 IDE 隨附的重構命令處理，以降低人為操作的錯誤，且盡可能在進行重構前加入測試，避免重構後發生錯誤。</p>
<p>本文記錄我過往經驗中，對於重構的一些想法與概念，也有在上課後老師所提供的想法。</p>]]></description></item></channel></rss>